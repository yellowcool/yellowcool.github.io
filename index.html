<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="c_night">
<meta property="og:type" content="website">
<meta property="og:title" content="coolyellow的博客">
<meta property="og:url" content="http://www.coolcoolcoder.com/c_night/index.html">
<meta property="og:site_name" content="coolyellow的博客">
<meta property="og:description" content="c_night">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coolyellow的博客">
<meta name="twitter:description" content="c_night">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.coolcoolcoder.com/c_night/"/>





  <title>coolyellow的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">coolyellow的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">cool</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.coolcoolcoder.com/c_night/2018/01/04/linux常用命令总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoolYellow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coolyellow的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/04/linux常用命令总结/" itemprop="url">linux常用命令总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-04T20:59:09+08:00">
                2018-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><h5 id="关于linux我们这里不深入研究，只总结一下常用的命令，以便为以后学习大数据打下基础。"><a href="#关于linux我们这里不深入研究，只总结一下常用的命令，以便为以后学习大数据打下基础。" class="headerlink" title="关于linux我们这里不深入研究，只总结一下常用的命令，以便为以后学习大数据打下基础。"></a>关于linux我们这里不深入研究，只总结一下常用的命令，以便为以后学习大数据打下基础。</h5><h3 id="二、linux常用基础"><a href="#二、linux常用基础" class="headerlink" title="二、linux常用基础"></a>二、linux常用基础</h3><ol>
<li>命令行字体变大<br>ctrl + shift + “+”</li>
<li>命令行字体变小<br>ctrl + “-“</li>
<li>查看当前所在路径<br>pwd</li>
<li>跳转到当前目录的上一级目录(当前目录的父目录)<br>cd .. </li>
<li>跳转到当前目录下的某一个目录<br>cd ./xxx’或者’cd xxx</li>
<li>回到上次的目录<br>cd -</li>
<li>回到当前用户的主目录下<br>cd ~</li>
<li>查看指定目录下的文件或者文件夹(不包括隐藏文件或者文件夹)<br>ls xxx</li>
<li>查看当前目录下的所有文件和文件夹(包括隐藏文件跟文件夹)<br>ls -a</li>
<li>查看当前目录下的文件和文件夹的详细信息<br>ls -l</li>
<li>查看当前目录下的文件和文件夹的格式化后的详细信息<br>ls -lh</li>
<li>查看当前目录下的所有以特殊清醒的文件或文件夹<br>ls *.txt //查看已后缀为txt的所有文件</li>
<li>自动补全<br>tab 单击时自动补全，双击时显示所有匹配成功的文件或者文件夹</li>
<li>清空当前的dos界面(并非真正意义上的清空，只是上移)<br>clear</li>
<li>查看当前dos窗口敲过的命令<br>history</li>
<li>创建文件<br>touch 文件名.后缀</li>
<li>重定向<br>“&gt;”（例如 ls -l &gt; test.txt,将详细信息保存到test.txt中，如果没有test.txt会重新创建，如果存在会删除其内容，然后再添加）<br>“&gt;&gt;” (例如 ls -l &gt;&gt; test.txt,将详细信息保存到test.txt中，如果没有会重新创建，如果存在会在文件末尾继续添加)</li>
<li>使用默认编辑器打开某一文件(gedit)<br>gedit xxx.txt</li>
<li>查看某一文件内容<br>cat xxx.txt</li>
<li>将两个文件内容合并到另一个文件中<br>cat 1.txt 2.txt &gt; 3.txt</li>
<li>创建文件夹<br>mkdir xxx</li>
<li>删除文件文件夹相关<ul>
<li>rmdir xxx //只能删除空文件夹</li>
<li>rm *.txt //删除某个文件</li>
<li>rm xxx -r //递归删除某个文件夹</li>
<li>rm *.txt -f //强制删除某个文件</li>
<li>rm *.txt -i //交互式删除某个文件，即删除前询问</li>
</ul>
</li>
<li>建立链接(源文件只能是文件不能是文件夹)<ul>
<li>硬链接：ln 源文件 链接文件(就是相当于给文件添加多个文件名，只有所有文件名都删除后才能真正的删除该文件)</li>
<li>软链接: ln -s 源文件 链接文件(不占用磁盘空间，源文件删除后，链接失效，相当于创建了快捷方式)</li>
</ul>
</li>
<li>搜索<ul>
<li>grep 搜索内容 搜索文件:grep “aa” 1.txt(搜索1.txt文件中的aa)</li>
<li>grep -n 搜索内容 搜索文件:grep -n “aa” 1.txt(搜索1.txt文件中的aa并显示所在行数)</li>
<li>grep -n 正则匹配规则 搜索文件:grep -n “^a”/“a$” 1.txt(搜索1.txt文件中的以a开头/以a结尾的内容，并显示所在行数)</li>
</ul>
</li>
<li>查找<br>find 要查找的目录 -name 要查找的文件：find xxx -name *.txt(查找xxx目录下的后缀名为txt的所有文件)</li>
<li>复制<ul>
<li>cp 要复制的文件 要复制到的文件夹路径: cp 1.txt test/(将1.txt文件复制到test文件夹下)</li>
<li>cp 要复制的文件 要复制到的文件夹路径 -v: cp 1.txt test/ -v (将1.txt文件复制到test文件夹下，并显示进度)</li>
<li>cp 要复制的文件夹 要复制到的文件夹路径 -a: cp test test2/ -a(将test文件夹整体复制到test2文件夹下)</li>
<li>cp 要复制的文件夹 要复制到的文件夹路径 -r: cp test test2/ -r(将test文件夹以递归的形式整体复制到test2文件夹下)</li>
</ul>
</li>
<li>移动(剪切)<ul>
<li>mv 要移动的文件 要移动到的文件夹路径: mv 1.txt test(将1.txt文件移动到test文件夹下)</li>
<li>mv 要移动的文件夹 要移动到的文件夹路径(-r可加可不加): mv test test2/(将test文件夹移动到test2文件夹下)</li>
<li>mv 1.txt 2.txt: 将文件1.txt改名为2.txt</li>
</ul>
</li>
<li><p>打包压缩减压缩<br>z:压缩    c:打包  x:减压  v：显示进度 f:指定档案名称，f后面必须是.tar，并且f必须放在选项最后</p>
<ul>
<li>tar -cvf test.tar 1.txt 2.txt 3.txt:将1.txt 2.txt 3.txt 打包成test.tar（只打包不压缩，大小不变）</li>
<li>tar -zcvf test.tar.gzip 1.txt 2.txt 3.txt:将1.txt 2.txt 3.txt 打包压缩成test.tar（即打包也压缩）</li>
<li>tar -xvf test.tar:减包test.tar</li>
<li>tar -zxvf test.tar.gzip:减压缩test.tar.gzip</li>
<li>tar -zxvf test.tar.gzip -C test/:减压缩test.tar.gzip到test目录下<br>bz2:</li>
<li>tar -jcvf test.tar.bz2 1.txt 2.txt 3.txt:将1.txt 2.txt 3.txt 打包压缩成test.tar.bz2（即打包也压缩）</li>
<li>tar -jxvf test.tar.bz2:减压缩test.tar.bz2</li>
</ul>
</li>
<li><p>gzip:压缩，减压</p>
<ul>
<li>gzip -r test.tar:压缩所有子目录到test.tar.gzip</li>
<li>gzip -d test.tar.gzip:减压缩test.tar.gzip</li>
</ul>
</li>
<li>zip unzip:压缩，减压缩<br>zip [-r] 目标文件（没有扩展名） 源文件 zip [-r] my 1.txt===&gt;my.zip<br>unzip -d 减压后目录文件 压缩文件:unzip -d test my.zip===&gt;将my.zip减压缩到test目录下</li>
<li>which：查看某个文件所在的目录<br>which ls:查看ls文件所在的目录</li>
<li>data：显示当前日期，时间<br>cal:显示当前日历 cal 2016:显示2016年的日历</li>
<li>ps:查看进程信息<ul>
<li>ps -a:显示终端上所有的进程，包括其他用户进程</li>
<li>ps -u：显示进程的详细状态</li>
<li>ps -x：显示没有控制终端的进程</li>
<li>ps -w：显示加宽，以便显示更多的信息</li>
<li>ps -r：只显示正在运行的进程<h5 id="常用的是-ps-aux"><a href="#常用的是-ps-aux" class="headerlink" title="常用的是 ps -aux"></a>常用的是 ps -aux</h5></li>
</ul>
</li>
<li>kill :杀死某个进程<br>先用ps -aux查看所有进程，然后kill 要杀死的进程前的编号（pid）<br>kill -9 pid:强制杀死某个进程</li>
<li>reboot：重启<ul>
<li>shutdown -r now:立刻重启</li>
<li>shutdown -h now:立刻关机</li>
<li>shutdown -h 20:35:在20:35时关机</li>
<li>shutdwon -h +10:10分钟后关机</li>
</ul>
</li>
<li>top：动态显示运行中的进程<br>按下top后可以根据如下按键得到队形的结果排序：<ul>
<li>M：根据内存使用量来排序</li>
<li>P:根据cup占有率来排序</li>
<li>T:根据进程运行时间长短来排序</li>
<li>U:可以根据后面输入的而用户名来筛选进程</li>
<li>K:可以根据后面输入的PID来杀死进程</li>
<li>q:退出</li>
<li>h:获得帮助</li>
</ul>
</li>
<li>df:查看磁盘的使用情况<br>df -lh:查看格式化后磁盘的使用情况</li>
<li>du:显示当前目录所占用的磁盘情况<br>du -alh:显示当前目录所有子目录所占磁盘的情况</li>
<li>ifconfig:查看当前PC的网卡信息等</li>
<li>ctrl+alt+f1~f6:进入非图形界面<ul>
<li>ctrl+alt+f7:进入图形界面</li>
<li>ctrl+alt:鼠标才能从非图形界面中出来</li>
</ul>
</li>
<li>ssh:远程登录<br>ssh 用户名@ip:远程登录某个用户名</li>
<li>who：查看当前登录的用户的信息<br>whoami:查看当前命令窗口是哪个用户在使用</li>
<li>useradd(adduser):添加用户（但是没有超级管理员，即不能使用sudo）<br>useradd yellowcool：添加用户名为yellowcool的用户，但没有家目录，即在home目录下没有yellowcool这个目录（一般每个用户在home中都有对应的目录）<br>useradd coolyellow -m:添加用户名为coolyellow的用户，并且在home目录下有其对应的目录</li>
<li>userdel:删除某个用户（该用户不能是正在登陆使用的，如果正在使用要exit再删除）<br>userdel 用户名：删除某个用户，但不删除其在home中的文件夹目录<br>userdel -r 用户名：删除某个用户，并且删除其在home中的文件夹目录</li>
<li>passwd:修改用户密码<br>passwd yellowcool:修改用户名为yellowcool的密码</li>
<li>su 用户名：切换到某个用户下</li>
<li>所有用户名都在/etc/passwd文件中<br>cat /etc/passwd查看</li>
<li>所有用户组都在/etc/group文件中<br>查看都有哪些用户组：<br> cat /etc/group或者groupmod 三次tab键</li>
<li>增加，删除组：<ul>
<li>groupadd 组名</li>
<li>groupdel 组名</li>
</ul>
</li>
<li>groups 用户名：查看用户名在哪个组中(只有在sudo组中的用户才具有超级管理员)<br>groups coolyellow</li>
<li>groupmod -g 用户组名 用户名：将某个用户添加到某个用户组中，会修改替换默认的用户组<ul>
<li>groupmod -G 用户组名 用户名：将某个用户添加到某个用户组中，会随机替换非默认用户组</li>
<li>groupmod -a -G 用户组名 用户名：将某个用户添加到某个用户组中,不修改任何用户组，直接添加到新的用户组中</li>
</ul>
</li>
<li>为创建的普通用户添加sudo权限，必须同时添加到adm跟sudo组中，必须在root用户下操作：<ul>
<li>sudo usermod -a -G adm 用户名</li>
<li>sudo usermod -a -G sudo 用户名（可能不需要sudo）</li>
</ul>
</li>
<li>chmod：修改权限(g:组 o:其他用户) <ul>
<li>chmod u+x 1.txt:为1.txt的拥有者添加可执行权限</li>
<li>chmod u-x 1.txt：修改拥有者为不可执行权限</li>
<li>chmod u=x 1.txt:修改拥有者的权限只为可执行</li>
<li>chmod 761 1.txt:该方式是最常用的<h5 id="注意：对于文件夹如果没有可执行权限，则进不去这个文件夹"><a href="#注意：对于文件夹如果没有可执行权限，则进不去这个文件夹" class="headerlink" title="注意：对于文件夹如果没有可执行权限，则进不去这个文件夹"></a>注意：对于文件夹如果没有可执行权限，则进不去这个文件夹</h5></li>
</ul>
</li>
<li>chown:修改文件的所有者<br>chown 用户名 文件或者目录名；</li>
<li>chgrp:修改文件所属组<br>chgrp 用户组名 文件或目录名</li>
<li>ubuntu软件安装与卸载：<br>1）修改Ubuntu默认的软件下载服务器，注意先备份<br> gedit /etc/apt/sources.list<br>2)从更新源地址：<a href="https://mirrors.tuna.tsinghua.edu.cn中找到Ubuntu对应的版本" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn中找到Ubuntu对应的版本</a><br> 然后复制到sources.list中的<a href="http://help.ubuntu.com...中，、" target="_blank" rel="external">http://help.ubuntu.com...中，、</a><br>3）执行apt-get update命令，验证是否成功（必须验证），让更新源生效<br>4）开始安装软件<br>   apt-get install 软件名<br>5）删除软件<br>   apt-get remove package</li>
<li>ftp服务器：文件上传下载协议（文件传输协议）<br>1）安装vsftpd服务器<br>  sudo apt-get install vsftpd<br>2)配置vsftpd.conf文件(验证上传文件是否合法)<br> sudo vi /etc/vsftpd.conf<br>3）重启FTP服务，使其生效<br> sudo /etc/init.d/vsftpd restart<br>4)登录ftp<br>5)上传或者下载文件<br> put somefile:上传某个文件<br> get somefile：下载某个文件</li>
<li>ssh服务器<br>1）安装ssh<br>sudo apt-get install openssh-server<br>2)远程登录<br> ssh 用户名@IP<br>3）远程拷贝<br> scp -r 目标用户名@目标主机IP：/目标文件的绝对路径   /保存到本机的绝对（或者相对）路径<br>① 本地文件复制到远程：（拷贝单个文件可以不加参数-r）<br>   scp filename remoteUserName@RemoteHostIp:RemoteFile<br>   scp filename RemoteHostIp:RemoteFile<br>② 本地目录复制到远程：<br>   scp -r foldername remoteUserName@RemoteHostIp:RemoteFolder<br>   scp -r foldername RemoteHostIp:RemoteFolder<br> ③ 远程文件复制到本地<br>   scp remoteUserName@RemoteHostIp:RemoteFile filename<br>   scp RemoteHostIp:RemoteFile  filename<br> ④ 远程目录复制到本地<br>   scp -r remoteUserName@RemoteHostIp:RemoteFolder  foldername<br>   scp -r RemoteHostIp:RemoteFolder  foldername </li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.coolcoolcoder.com/c_night/2017/12/23/Hadoop安装与配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoolYellow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coolyellow的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/23/Hadoop安装与配置/" itemprop="url">Hadoop安装与配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-23T19:14:05+08:00">
                2017-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HADOOP/" itemprop="url" rel="index">
                    <span itemprop="name">HADOOP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、Hadoop安装"><a href="#一、Hadoop安装" class="headerlink" title="一、Hadoop安装"></a>一、Hadoop安装</h3><ol>
<li>下载Hadoop并减压到指定目录</li>
<li>配置Hadoop环境变量：<br> 在/etc目录下的environment中添加HADOOP_INSTALL=你所减压的Hadoop的目录（注意这里不包含”/“,例如：”/usr/soft/hadoop”;然后在path中添加bin跟sbin路径，例如：”:/usr/soft/hadoop/bin:/usr/soft/hadoop/sbin”）</li>
<li>使环境变量立即生效：<br> 执行”source environment”命令</li>
<li>查看Hadoop是否安装成功：<br> 执行”hadoop version”命令，如果没报错，并显示了Hadoop的版本则说明配置陈宫了（注意如果未安装jdk或未配置JAVA_HOME需要先安装跟配置jdk的环境变量，如果安装并配置了jdk仍然报错，可能需要重启系统来生效）<h3 id="二、Hadoop配置模式"><a href="#二、Hadoop配置模式" class="headerlink" title="二、Hadoop配置模式"></a>二、Hadoop配置模式</h3><h5 id="使用jps命令查看当前运行的进程"><a href="#使用jps命令查看当前运行的进程" class="headerlink" title="使用jps命令查看当前运行的进程"></a>使用jps命令查看当前运行的进程</h5></li>
<li>独立模式<br> 输入命令行与Linux一样只是需要以”hadoop fs”开始(例如”hadoop fs -ls /“查看/下的所有文件及其文件夹)</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.coolcoolcoder.com/c_night/2017/12/23/ubuntu代理设置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoolYellow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coolyellow的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/23/ubuntu代理设置/" itemprop="url">ubuntu代理设置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-23T16:15:37+08:00">
                2017-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ubuntu/" itemprop="url" rel="index">
                    <span itemprop="name">ubuntu</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.修改ubuntu代理</p>
<h5 id="进入etc-apt中备份source-list文件，然后拷贝其他代理到souorce-list中，保存后，执行sudo-apt-get-update进行更新源"><a href="#进入etc-apt中备份source-list文件，然后拷贝其他代理到souorce-list中，保存后，执行sudo-apt-get-update进行更新源" class="headerlink" title="进入etc/apt中备份source.list文件，然后拷贝其他代理到souorce.list中，保存后，执行sudo apt-get update进行更新源"></a>进入etc/apt中备份source.list文件，然后拷贝其他代理到souorce.list中，保存后，执行sudo apt-get update进行更新源</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.coolcoolcoder.com/c_night/2017/11/12/Android消息机制从源码分析Handelr、Looper、Message/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoolYellow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coolyellow的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/12/Android消息机制从源码分析Handelr、Looper、Message/" itemprop="url">Android消息机制从源码分析Handelr、Looper、Message</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T10:24:12+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h5 id="关于Android消息机制想必大家都非常熟悉了，而且面试必问问题之一，如果我们仍旧只是知道怎么使用，那就太更不上时代步伐了，想想当面试问你handler机制时，你从源码给其分析一遍，那你已经踏进offer大门一只左脚了，所以这里我们一起从源码查看一下消息机制。"><a href="#关于Android消息机制想必大家都非常熟悉了，而且面试必问问题之一，如果我们仍旧只是知道怎么使用，那就太更不上时代步伐了，想想当面试问你handler机制时，你从源码给其分析一遍，那你已经踏进offer大门一只左脚了，所以这里我们一起从源码查看一下消息机制。" class="headerlink" title="关于Android消息机制想必大家都非常熟悉了，而且面试必问问题之一，如果我们仍旧只是知道怎么使用，那就太更不上时代步伐了，想想当面试问你handler机制时，你从源码给其分析一遍，那你已经踏进offer大门一只左脚了，所以这里我们一起从源码查看一下消息机制。"></a>关于Android消息机制想必大家都非常熟悉了，而且面试必问问题之一，如果我们仍旧只是知道怎么使用，那就太更不上时代步伐了，想想当面试问你handler机制时，你从源码给其分析一遍，那你已经踏进offer大门一只左脚了，所以这里我们一起从源码查看一下消息机制。</h5><h2 id="二、源码解析"><a href="#二、源码解析" class="headerlink" title="二、源码解析"></a>二、源码解析</h2><h3 id="1、ActivityThread-main-方法跟Looper"><a href="#1、ActivityThread-main-方法跟Looper" class="headerlink" title="1、ActivityThread.main()方法跟Looper"></a>1、ActivityThread.main()方法跟Looper</h3><h5 id="我刚接触android时，大家都跟我说application的oncreate方法是，APP的入口，但这其实是不正确的，APP的真正的入口是ActivityThread类的main方法，这里要注意虽然叫ActivityThread其实它并不是我们平时所说的线程，由于我们这里只是分析消息机制，所以感兴趣的小伙伴可以自己去查询一下相关知识，既然main方法是入口，那我们就看看APP在启动时都做了什么，源码如下："><a href="#我刚接触android时，大家都跟我说application的oncreate方法是，APP的入口，但这其实是不正确的，APP的真正的入口是ActivityThread类的main方法，这里要注意虽然叫ActivityThread其实它并不是我们平时所说的线程，由于我们这里只是分析消息机制，所以感兴趣的小伙伴可以自己去查询一下相关知识，既然main方法是入口，那我们就看看APP在启动时都做了什么，源码如下：" class="headerlink" title="我刚接触android时，大家都跟我说application的oncreate方法是，APP的入口，但这其实是不正确的，APP的真正的入口是ActivityThread类的main方法，这里要注意虽然叫ActivityThread其实它并不是我们平时所说的线程，由于我们这里只是分析消息机制，所以感兴趣的小伙伴可以自己去查询一下相关知识，既然main方法是入口，那我们就看看APP在启动时都做了什么，源码如下："></a>我刚接触android时，大家都跟我说application的oncreate方法是，APP的入口，但这其实是不正确的，APP的真正的入口是ActivityThread类的main方法，这里要注意虽然叫ActivityThread其实它并不是我们平时所说的线程，由于我们这里只是分析消息机制，所以感兴趣的小伙伴可以自己去查询一下相关知识，既然main方法是入口，那我们就看看APP在启动时都做了什么，源码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">  public static void main(String[] args) &#123;</div><div class="line">//省略代码</div><div class="line">......</div><div class="line">       Looper.prepareMainLooper();</div><div class="line"></div><div class="line">       ActivityThread thread = new ActivityThread();</div><div class="line">       thread.attach(false);</div><div class="line"></div><div class="line">       if (sMainThreadHandler == null) &#123;</div><div class="line">           sMainThreadHandler = thread.getHandler();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (false) &#123;</div><div class="line">           Looper.myLooper().setMessageLogging(new</div><div class="line">                   LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // End of event ActivityThreadMain.</div><div class="line">       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">       Looper.loop();</div><div class="line"></div><div class="line">       throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="我们很容易注意到-Looper-prepareMainLooper-，Looper-loop-这两句代码，具体他们都是做什么的，我们一个一个来分析，先来看看第一句源码："><a href="#我们很容易注意到-Looper-prepareMainLooper-，Looper-loop-这两句代码，具体他们都是做什么的，我们一个一个来分析，先来看看第一句源码：" class="headerlink" title="我们很容易注意到 Looper.prepareMainLooper()，Looper.loop()这两句代码，具体他们都是做什么的，我们一个一个来分析，先来看看第一句源码："></a>我们很容易注意到 Looper.prepareMainLooper()，Looper.loop()这两句代码，具体他们都是做什么的，我们一个一个来分析，先来看看第一句源码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void prepareMainLooper() &#123;</div><div class="line">        prepare(false);</div><div class="line">        synchronized (Looper.class) &#123;</div><div class="line">            if (sMainLooper != null) &#123;</div><div class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</div><div class="line">            &#125;</div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="这里又调用了prepare-false-跟myLooper-方法"><a href="#这里又调用了prepare-false-跟myLooper-方法" class="headerlink" title="这里又调用了prepare(false)跟myLooper()方法"></a>这里又调用了prepare(false)跟myLooper()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">        if (sThreadLocal.get() != null) &#123;</div><div class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">        &#125;</div><div class="line">        sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  public static @Nullable Looper myLooper() &#123;</div><div class="line">        return sThreadLocal.get();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="prepare-false-方法大家很熟悉了吧，其实它内部非常简单，就几行代码，这里就要涉及另一个类ThreadLocal了，这个类我们一样不详细说明了，感兴趣的小伙伴多去查询吧，ThreadLocal这个类是用来绑定当前线程的，我们这里就当做一个map使用即可，好，我们再来看prepare方法，先是判断当前线程是否已经绑定Looper了，如果绑定就抛出异常，这也就说明了，一个线程只能有一个Looper实例，如果没有绑定，我们就new出一个实例并且绑定到当前线程。"><a href="#prepare-false-方法大家很熟悉了吧，其实它内部非常简单，就几行代码，这里就要涉及另一个类ThreadLocal了，这个类我们一样不详细说明了，感兴趣的小伙伴多去查询吧，ThreadLocal这个类是用来绑定当前线程的，我们这里就当做一个map使用即可，好，我们再来看prepare方法，先是判断当前线程是否已经绑定Looper了，如果绑定就抛出异常，这也就说明了，一个线程只能有一个Looper实例，如果没有绑定，我们就new出一个实例并且绑定到当前线程。" class="headerlink" title="prepare(false)方法大家很熟悉了吧，其实它内部非常简单，就几行代码，这里就要涉及另一个类ThreadLocal了，这个类我们一样不详细说明了，感兴趣的小伙伴多去查询吧，ThreadLocal这个类是用来绑定当前线程的，我们这里就当做一个map使用即可，好，我们再来看prepare方法，先是判断当前线程是否已经绑定Looper了，如果绑定就抛出异常，这也就说明了，一个线程只能有一个Looper实例，如果没有绑定，我们就new出一个实例并且绑定到当前线程。"></a>prepare(false)方法大家很熟悉了吧，其实它内部非常简单，就几行代码，这里就要涉及另一个类ThreadLocal了，这个类我们一样不详细说明了，感兴趣的小伙伴多去查询吧，ThreadLocal这个类是用来绑定当前线程的，我们这里就当做一个map使用即可，好，我们再来看prepare方法，先是判断当前线程是否已经绑定Looper了，如果绑定就抛出异常，这也就说明了，一个线程只能有一个Looper实例，如果没有绑定，我们就new出一个实例并且绑定到当前线程。</h5><h5 id="myLooper-方法更简单了，就是从当前线程获取绑定的Looper实例。"><a href="#myLooper-方法更简单了，就是从当前线程获取绑定的Looper实例。" class="headerlink" title="myLooper()方法更简单了，就是从当前线程获取绑定的Looper实例。"></a>myLooper()方法更简单了，就是从当前线程获取绑定的Looper实例。</h5><h5 id="也就是说prepareMainLooper-方法就是创建一个Looper并与当前线程绑定，那么loop-方法又做了什么呢，源码如下："><a href="#也就是说prepareMainLooper-方法就是创建一个Looper并与当前线程绑定，那么loop-方法又做了什么呢，源码如下：" class="headerlink" title="也就是说prepareMainLooper()方法就是创建一个Looper并与当前线程绑定，那么loop()方法又做了什么呢，源码如下："></a>也就是说prepareMainLooper()方法就是创建一个Looper并与当前线程绑定，那么loop()方法又做了什么呢，源码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line">       final Looper me = myLooper();</div><div class="line">       if (me == null) &#123;</div><div class="line">           throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">       &#125;</div><div class="line">       final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">       for (;;) &#123;</div><div class="line">           Message msg = queue.next(); // might block</div><div class="line">           if (msg == null) &#123;</div><div class="line">               // No message indicates that the message queue is quitting.</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           try &#123;</div><div class="line">               msg.target.dispatchMessage(msg);</div><div class="line">               end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</div><div class="line">           &#125; finally &#123;</div><div class="line">               if (traceTag != 0) &#123;</div><div class="line">                   Trace.traceEnd(traceTag);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           msg.recycleUnchecked();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="loop-方法我这里只贴出了需要的代码，这里第一句也是调用了myLooper-方法，也即获取当前线程绑定的Looper，而me-mQueue是什么呢，其实就是message内部的一个MessageQueue，我们看一下Looper的构造方法："><a href="#loop-方法我这里只贴出了需要的代码，这里第一句也是调用了myLooper-方法，也即获取当前线程绑定的Looper，而me-mQueue是什么呢，其实就是message内部的一个MessageQueue，我们看一下Looper的构造方法：" class="headerlink" title="loop()方法我这里只贴出了需要的代码，这里第一句也是调用了myLooper()方法，也即获取当前线程绑定的Looper，而me.mQueue是什么呢，其实就是message内部的一个MessageQueue，我们看一下Looper的构造方法："></a>loop()方法我这里只贴出了需要的代码，这里第一句也是调用了myLooper()方法，也即获取当前线程绑定的Looper，而me.mQueue是什么呢，其实就是message内部的一个MessageQueue，我们看一下Looper的构造方法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">      mQueue = new MessageQueue(quitAllowed);</div><div class="line">      mThread = Thread.currentThread();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="就两句代码第一句就是创建了一个MessageQueue，第二句就是获取当前线程，由于一个线程只能有一个Looper实例，而一个Looper实例也只创建一个MessageQueue实例，所以一个线程只能绑定一个MessageQueue实例，好了，我们接着看loop-方法，获取message内部的messageQueue实例后，接着就是一个死循坏，当然这里说是死循坏并不恰当，后面我们会说明为什么，这个循坏里面不断从消息队列messageQueue中获取message实例，注意这句话might-bolck意思是说可能会阻塞，具体我们后面会说道，接下来，获取到message实例后会调用message-target-dispatchMessage-msg-方法，这里的target其实就是发送该message的handel看下message创建实例的方法："><a href="#就两句代码第一句就是创建了一个MessageQueue，第二句就是获取当前线程，由于一个线程只能有一个Looper实例，而一个Looper实例也只创建一个MessageQueue实例，所以一个线程只能绑定一个MessageQueue实例，好了，我们接着看loop-方法，获取message内部的messageQueue实例后，接着就是一个死循坏，当然这里说是死循坏并不恰当，后面我们会说明为什么，这个循坏里面不断从消息队列messageQueue中获取message实例，注意这句话might-bolck意思是说可能会阻塞，具体我们后面会说道，接下来，获取到message实例后会调用message-target-dispatchMessage-msg-方法，这里的target其实就是发送该message的handel看下message创建实例的方法：" class="headerlink" title="就两句代码第一句就是创建了一个MessageQueue，第二句就是获取当前线程，由于一个线程只能有一个Looper实例，而一个Looper实例也只创建一个MessageQueue实例，所以一个线程只能绑定一个MessageQueue实例，好了，我们接着看loop()方法，获取message内部的messageQueue实例后，接着就是一个死循坏，当然这里说是死循坏并不恰当，后面我们会说明为什么，这个循坏里面不断从消息队列messageQueue中获取message实例，注意这句话might bolck意思是说可能会阻塞，具体我们后面会说道，接下来，获取到message实例后会调用message.target.dispatchMessage(msg)方法，这里的target其实就是发送该message的handel看下message创建实例的方法："></a>就两句代码第一句就是创建了一个MessageQueue，第二句就是获取当前线程，由于一个线程只能有一个Looper实例，而一个Looper实例也只创建一个MessageQueue实例，所以一个线程只能绑定一个MessageQueue实例，好了，我们接着看loop()方法，获取message内部的messageQueue实例后，接着就是一个死循坏，当然这里说是死循坏并不恰当，后面我们会说明为什么，这个循坏里面不断从消息队列messageQueue中获取message实例，注意这句话might bolck意思是说可能会阻塞，具体我们后面会说道，接下来，获取到message实例后会调用message.target.dispatchMessage(msg)方法，这里的target其实就是发送该message的handel看下message创建实例的方法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static Message obtain(Handler h) &#123;</div><div class="line">       Message m = obtain();</div><div class="line">       m.target = h;</div><div class="line"></div><div class="line">       return m;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="很清楚这里创建message实例时要传入一个handler，也就是每一个message都要绑定发送它的handler。而handler-despatchMessage-message-方法都做了什么呢，源码如下："><a href="#很清楚这里创建message实例时要传入一个handler，也就是每一个message都要绑定发送它的handler。而handler-despatchMessage-message-方法都做了什么呢，源码如下：" class="headerlink" title="很清楚这里创建message实例时要传入一个handler，也就是每一个message都要绑定发送它的handler。而handler.despatchMessage(message)方法都做了什么呢，源码如下："></a>很清楚这里创建message实例时要传入一个handler，也就是每一个message都要绑定发送它的handler。而handler.despatchMessage(message)方法都做了什么呢，源码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">       if (msg.callback != null) &#123;</div><div class="line">           handleCallback(msg);</div><div class="line">       &#125; else &#123;</div><div class="line">           if (mCallback != null) &#123;</div><div class="line">               if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                   return;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           handleMessage(msg);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="可以看到其实就是调用了我们重写的handlerMessage-方法了，这也就是为什么我们创建handler时经常要重写handlerMessage方法了。好了我们这里先大概总结一下：首先先调用Looper-prepare方法创建一个Looper实例并且让该实例与当前线程绑定，以保证一个线程只有一个Looper实例，而创建Looper实例时，我们有在内部创建了一个消息队列MessageQueue实例，其次我们调用了Looper-loop方法，该方法内先获取当前线程绑定的Looper实例，并且从该Looper实例获取对应的消息队列，然后进入死循坏不断从消息队列中获取消息，一旦获取消息后，就调用发送该消息的handler的dispatchMessage方法处理该消息。那么消息是如何添加到对应的消息队列呢？"><a href="#可以看到其实就是调用了我们重写的handlerMessage-方法了，这也就是为什么我们创建handler时经常要重写handlerMessage方法了。好了我们这里先大概总结一下：首先先调用Looper-prepare方法创建一个Looper实例并且让该实例与当前线程绑定，以保证一个线程只有一个Looper实例，而创建Looper实例时，我们有在内部创建了一个消息队列MessageQueue实例，其次我们调用了Looper-loop方法，该方法内先获取当前线程绑定的Looper实例，并且从该Looper实例获取对应的消息队列，然后进入死循坏不断从消息队列中获取消息，一旦获取消息后，就调用发送该消息的handler的dispatchMessage方法处理该消息。那么消息是如何添加到对应的消息队列呢？" class="headerlink" title="可以看到其实就是调用了我们重写的handlerMessage()方法了，这也就是为什么我们创建handler时经常要重写handlerMessage方法了。好了我们这里先大概总结一下：首先先调用Looper.prepare方法创建一个Looper实例并且让该实例与当前线程绑定，以保证一个线程只有一个Looper实例，而创建Looper实例时，我们有在内部创建了一个消息队列MessageQueue实例，其次我们调用了Looper.loop方法，该方法内先获取当前线程绑定的Looper实例，并且从该Looper实例获取对应的消息队列，然后进入死循坏不断从消息队列中获取消息，一旦获取消息后，就调用发送该消息的handler的dispatchMessage方法处理该消息。那么消息是如何添加到对应的消息队列呢？"></a>可以看到其实就是调用了我们重写的handlerMessage()方法了，这也就是为什么我们创建handler时经常要重写handlerMessage方法了。好了我们这里先大概总结一下：首先先调用Looper.prepare方法创建一个Looper实例并且让该实例与当前线程绑定，以保证一个线程只有一个Looper实例，而创建Looper实例时，我们有在内部创建了一个消息队列MessageQueue实例，其次我们调用了Looper.loop方法，该方法内先获取当前线程绑定的Looper实例，并且从该Looper实例获取对应的消息队列，然后进入死循坏不断从消息队列中获取消息，一旦获取消息后，就调用发送该消息的handler的dispatchMessage方法处理该消息。那么消息是如何添加到对应的消息队列呢？</h5><h3 id="2、Hander源码分析"><a href="#2、Hander源码分析" class="headerlink" title="2、Hander源码分析"></a>2、Hander源码分析</h3><h5 id="我们平时使用handler发送消息有很多种，我们这里只分析其中一种sendMessage-Message-msg-，其他的类似-源码如下："><a href="#我们平时使用handler发送消息有很多种，我们这里只分析其中一种sendMessage-Message-msg-，其他的类似-源码如下：" class="headerlink" title="我们平时使用handler发送消息有很多种，我们这里只分析其中一种sendMessage(Message msg)，其他的类似,源码如下："></a>我们平时使用handler发送消息有很多种，我们这里只分析其中一种sendMessage(Message msg)，其他的类似,源码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final boolean sendMessage(Message msg)</div><div class="line">   &#123;</div><div class="line">       return sendMessageDelayed(msg, 0);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="其调用了sendMessageDelayed-msg-0-方法，其源码如下："><a href="#其调用了sendMessageDelayed-msg-0-方法，其源码如下：" class="headerlink" title="其调用了sendMessageDelayed(msg,0)方法，其源码如下："></a>其调用了sendMessageDelayed(msg,0)方法，其源码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</div><div class="line">  &#123;</div><div class="line">      if (delayMillis &lt; 0) &#123;</div><div class="line">          delayMillis = 0;</div><div class="line">      &#125;</div><div class="line">      return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="其内部又调用了sendMessageAtTime方法："><a href="#其内部又调用了sendMessageAtTime方法：" class="headerlink" title="其内部又调用了sendMessageAtTime方法："></a>其内部又调用了sendMessageAtTime方法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">      MessageQueue queue = mQueue;</div><div class="line">      if (queue == null) &#123;</div><div class="line">          RuntimeException e = new RuntimeException(</div><div class="line">                  this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">          Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">          return false;</div><div class="line">      &#125;</div><div class="line">      return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h5 id="这个方法也很简单，先是获取对应的消息队列，然后调用enqueueMessage方法，将message加入到该消息队列中："><a href="#这个方法也很简单，先是获取对应的消息队列，然后调用enqueueMessage方法，将message加入到该消息队列中：" class="headerlink" title="这个方法也很简单，先是获取对应的消息队列，然后调用enqueueMessage方法，将message加入到该消息队列中："></a>这个方法也很简单，先是获取对应的消息队列，然后调用enqueueMessage方法，将message加入到该消息队列中：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">        msg.target = this;</div><div class="line">        if (mAsynchronous) &#123;</div><div class="line">            msg.setAsynchronous(true);</div><div class="line">        &#125;</div><div class="line">        return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="可以看到enqueueMessage方法先是将handler存到要发送的message中，再调用messageQueue-enqueueMessage方法，将消息加入到消息队列中，这样在Looper-loop启动后就可以获取到该message了。"><a href="#可以看到enqueueMessage方法先是将handler存到要发送的message中，再调用messageQueue-enqueueMessage方法，将消息加入到消息队列中，这样在Looper-loop启动后就可以获取到该message了。" class="headerlink" title="可以看到enqueueMessage方法先是将handler存到要发送的message中，再调用messageQueue.enqueueMessage方法，将消息加入到消息队列中，这样在Looper.loop启动后就可以获取到该message了。"></a>可以看到enqueueMessage方法先是将handler存到要发送的message中，再调用messageQueue.enqueueMessage方法，将消息加入到消息队列中，这样在Looper.loop启动后就可以获取到该message了。</h5><h5 id="好了，我们再来总结一下"><a href="#好了，我们再来总结一下" class="headerlink" title="好了，我们再来总结一下:"></a>好了，我们再来总结一下:</h5><ol>
<li>Looper.prepare()在本线程中创建一个Looper实例，在该实例中创建一个消息队列MessageQueue实例，因为一个线程只能有一个Looper实例，所以一个线程也就只能有一个消息队列。</li>
<li>Looper.loop()方法会让当前线程进入一个无限循坏中，不断从消息队列中获取message，当获取到message时，就交给发送该消息的handler处理，如果没获取到message则进入阻塞。</li>
<li>Hander实例创建时，会先获取到当前线程的Looper实例，然后通过该Looper实例获取到消息队列。</li>
<li>Hander.sendMessage方法，会给message绑定handler本身，然后加入到该线程的消息队列中。</li>
<li>消息机制是基于同一个线程而言的，也就是说同一个线程的handler只能发送message到同一个线程的消息队列中。<h5 id="四、后记"><a href="#四、后记" class="headerlink" title="四、后记"></a>四、后记</h5><h5 id="前面我们说过messagequeue-next方法会阻塞线程以及Looper-loop方法会进入死循坏中，那么这就涉及到另一个问题，在主线程中为什么死循坏不会造成ANR呢？"><a href="#前面我们说过messagequeue-next方法会阻塞线程以及Looper-loop方法会进入死循坏中，那么这就涉及到另一个问题，在主线程中为什么死循坏不会造成ANR呢？" class="headerlink" title="前面我们说过messagequeue.next方法会阻塞线程以及Looper.loop方法会进入死循坏中，那么这就涉及到另一个问题，在主线程中为什么死循坏不会造成ANR呢？"></a>前面我们说过messagequeue.next方法会阻塞线程以及Looper.loop方法会进入死循坏中，那么这就涉及到另一个问题，在主线程中为什么死循坏不会造成ANR呢？</h5><h5 id="首先，我们要理解什么是ANR-ANR是指某一事件长时间未得到相应。比如说，我们先点击某一个button的点击事件，再点击另一个button的点击事件，假如这里不牵扯多线程问题，如果第一个button有耗时操作超过5s，那么第二个button的点击事件，只能在消息队列中等候，当长时间未轮到第二个button的点击事件的message时，就会报ANR。既然知道了什么是ANR，那么为什么next方法阻塞线程时不会报ANR呢，其实这里的阻塞并不是我们平时说的阻塞，我们可以理解为休眠，当消息队列中没有消息时，线程会进入休眠状态，当来新的消息时，会被唤醒，其实在主线程中我们可以看到activity等的生命周期都在一个继承Handler的类H中进行管理的，而如果主线程并不是死循环的话，当走完生命周期，那么这个线程也就结束了，我们的程序也就退出去了，所以这里设计成死循环也是为了让程序一直运行。"><a href="#首先，我们要理解什么是ANR-ANR是指某一事件长时间未得到相应。比如说，我们先点击某一个button的点击事件，再点击另一个button的点击事件，假如这里不牵扯多线程问题，如果第一个button有耗时操作超过5s，那么第二个button的点击事件，只能在消息队列中等候，当长时间未轮到第二个button的点击事件的message时，就会报ANR。既然知道了什么是ANR，那么为什么next方法阻塞线程时不会报ANR呢，其实这里的阻塞并不是我们平时说的阻塞，我们可以理解为休眠，当消息队列中没有消息时，线程会进入休眠状态，当来新的消息时，会被唤醒，其实在主线程中我们可以看到activity等的生命周期都在一个继承Handler的类H中进行管理的，而如果主线程并不是死循环的话，当走完生命周期，那么这个线程也就结束了，我们的程序也就退出去了，所以这里设计成死循环也是为了让程序一直运行。" class="headerlink" title="首先，我们要理解什么是ANR,ANR是指某一事件长时间未得到相应。比如说，我们先点击某一个button的点击事件，再点击另一个button的点击事件，假如这里不牵扯多线程问题，如果第一个button有耗时操作超过5s，那么第二个button的点击事件，只能在消息队列中等候，当长时间未轮到第二个button的点击事件的message时，就会报ANR。既然知道了什么是ANR，那么为什么next方法阻塞线程时不会报ANR呢，其实这里的阻塞并不是我们平时说的阻塞，我们可以理解为休眠，当消息队列中没有消息时，线程会进入休眠状态，当来新的消息时，会被唤醒，其实在主线程中我们可以看到activity等的生命周期都在一个继承Handler的类H中进行管理的，而如果主线程并不是死循环的话，当走完生命周期，那么这个线程也就结束了，我们的程序也就退出去了，所以这里设计成死循环也是为了让程序一直运行。"></a>首先，我们要理解什么是ANR,ANR是指某一事件长时间未得到相应。比如说，我们先点击某一个button的点击事件，再点击另一个button的点击事件，假如这里不牵扯多线程问题，如果第一个button有耗时操作超过5s，那么第二个button的点击事件，只能在消息队列中等候，当长时间未轮到第二个button的点击事件的message时，就会报ANR。既然知道了什么是ANR，那么为什么next方法阻塞线程时不会报ANR呢，其实这里的阻塞并不是我们平时说的阻塞，我们可以理解为休眠，当消息队列中没有消息时，线程会进入休眠状态，当来新的消息时，会被唤醒，其实在主线程中我们可以看到activity等的生命周期都在一个继承Handler的类H中进行管理的，而如果主线程并不是死循环的话，当走完生命周期，那么这个线程也就结束了，我们的程序也就退出去了，所以这里设计成死循环也是为了让程序一直运行。</h5></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.coolcoolcoder.com/c_night/2017/11/06/Gradle使用技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoolYellow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coolyellow的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/06/Gradle使用技巧/" itemprop="url">Gradle使用技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T20:38:41+08:00">
                2017-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h5 id="在这一节中，我们总结一下在实际开发中Gradle的一些使用技巧。"><a href="#在这一节中，我们总结一下在实际开发中Gradle的一些使用技巧。" class="headerlink" title="在这一节中，我们总结一下在实际开发中Gradle的一些使用技巧。"></a>在这一节中，我们总结一下在实际开发中Gradle的一些使用技巧。</h5><h2 id="二、技巧"><a href="#二、技巧" class="headerlink" title="二、技巧"></a>二、技巧</h2><ol>
<li><p>Gradle peer not authenticated</p>
<h5 id="在更新Gradle依赖包事，经常会出现这个错误，导致Gradle编译失败，相信大家已经知道怎么解决了，使用VPN进行网络访问即可，另外通过修改jcenter库的地址也能修复这个问题："><a href="#在更新Gradle依赖包事，经常会出现这个错误，导致Gradle编译失败，相信大家已经知道怎么解决了，使用VPN进行网络访问即可，另外通过修改jcenter库的地址也能修复这个问题：" class="headerlink" title="在更新Gradle依赖包事，经常会出现这个错误，导致Gradle编译失败，相信大家已经知道怎么解决了，使用VPN进行网络访问即可，另外通过修改jcenter库的地址也能修复这个问题："></a>在更新Gradle依赖包事，经常会出现这个错误，导致Gradle编译失败，相信大家已经知道怎么解决了，使用VPN进行网络访问即可，另外通过修改jcenter库的地址也能修复这个问题：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jcenter&#123;</div><div class="line">    url &quot;http://jcenter.bintray.com/&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Gradle性能检测</p>
<h5 id="其实Gradle编译工具本身就内置了性能分析工具—profile。通过Gradle编译的使用，只需要增加-profile参数即可打开这个功能。执行一下脚本："><a href="#其实Gradle编译工具本身就内置了性能分析工具—profile。通过Gradle编译的使用，只需要增加-profile参数即可打开这个功能。执行一下脚本：" class="headerlink" title="其实Gradle编译工具本身就内置了性能分析工具—profile。通过Gradle编译的使用，只需要增加-profile参数即可打开这个功能。执行一下脚本："></a>其实Gradle编译工具本身就内置了性能分析工具—profile。通过Gradle编译的使用，只需要增加-profile参数即可打开这个功能。执行一下脚本：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gradle build -profile</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="通过以上脚本，我们就可以在根目录的Build目录下生成一个profile文件，该文件显示了完整的Grdle编译过程的耗时，通过查看这个profiel文件，就可以进一步优化Gradle脚本。例如关闭lint这个task、在debug版本中，可以使用以下代码提高AAPT的速度："><a href="#通过以上脚本，我们就可以在根目录的Build目录下生成一个profile文件，该文件显示了完整的Grdle编译过程的耗时，通过查看这个profiel文件，就可以进一步优化Gradle脚本。例如关闭lint这个task、在debug版本中，可以使用以下代码提高AAPT的速度：" class="headerlink" title="通过以上脚本，我们就可以在根目录的Build目录下生成一个profile文件，该文件显示了完整的Grdle编译过程的耗时，通过查看这个profiel文件，就可以进一步优化Gradle脚本。例如关闭lint这个task、在debug版本中，可以使用以下代码提高AAPT的速度："></a>通过以上脚本，我们就可以在根目录的Build目录下生成一个profile文件，该文件显示了完整的Grdle编译过程的耗时，通过查看这个profiel文件，就可以进一步优化Gradle脚本。例如关闭lint这个task、在debug版本中，可以使用以下代码提高AAPT的速度：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aaptOptions &#123;</div><div class="line">    cruncherEnabled = false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="这里要注意，由于资源没有经过AAPT优化，可能会导致一些运行问题，所以最好只在Debug时采用，而在release时一定不要采用。"><a href="#这里要注意，由于资源没有经过AAPT优化，可能会导致一些运行问题，所以最好只在Debug时采用，而在release时一定不要采用。" class="headerlink" title="这里要注意，由于资源没有经过AAPT优化，可能会导致一些运行问题，所以最好只在Debug时采用，而在release时一定不要采用。"></a>这里要注意，由于资源没有经过AAPT优化，可能会导致一些运行问题，所以最好只在Debug时采用，而在release时一定不要采用。</h5><ol>
<li>Gradle加速<h5 id="前面我们介绍了如何对Gradle的task进行加速，接下来我们就从Gradle本身讲解如何提速。由于Gradle在编译期间会执行大量的task，同时生成大量的中间文件，所以磁盘IO会造成编译速度慢，解决该问题最好的方式是使用固态硬盘，同时减少本地库项目的依赖，多使用aar进行依赖。其次，可以在gradle-properties文件中增加如下代码："><a href="#前面我们介绍了如何对Gradle的task进行加速，接下来我们就从Gradle本身讲解如何提速。由于Gradle在编译期间会执行大量的task，同时生成大量的中间文件，所以磁盘IO会造成编译速度慢，解决该问题最好的方式是使用固态硬盘，同时减少本地库项目的依赖，多使用aar进行依赖。其次，可以在gradle-properties文件中增加如下代码：" class="headerlink" title="前面我们介绍了如何对Gradle的task进行加速，接下来我们就从Gradle本身讲解如何提速。由于Gradle在编译期间会执行大量的task，同时生成大量的中间文件，所以磁盘IO会造成编译速度慢，解决该问题最好的方式是使用固态硬盘，同时减少本地库项目的依赖，多使用aar进行依赖。其次，可以在gradle.properties文件中增加如下代码："></a>前面我们介绍了如何对Gradle的task进行加速，接下来我们就从Gradle本身讲解如何提速。由于Gradle在编译期间会执行大量的task，同时生成大量的中间文件，所以磁盘IO会造成编译速度慢，解决该问题最好的方式是使用固态硬盘，同时减少本地库项目的依赖，多使用aar进行依赖。其次，可以在gradle.properties文件中增加如下代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">org.gradle.daemo =true</div><div class="line">org.gradle.parallel=true</div><div class="line">org.gradle.configureondemand = true</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="同时，在build-gradle中增加如下代码："><a href="#同时，在build-gradle中增加如下代码：" class="headerlink" title="同时，在build.gradle中增加如下代码："></a>同时，在build.gradle中增加如下代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dexOptions &#123;</div><div class="line">    incremental true</div><div class="line">	javaMaxHeapSize &quot;4g&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="gradle-properties文件中的代码，表示开启Gradle的多线程跟多核心支持。而build-gradle中的代码，表示开启Gradle的增量编译，增加编译的内存到4G。"><a href="#gradle-properties文件中的代码，表示开启Gradle的多线程跟多核心支持。而build-gradle中的代码，表示开启Gradle的增量编译，增加编译的内存到4G。" class="headerlink" title="gradle.properties文件中的代码，表示开启Gradle的多线程跟多核心支持。而build.gradle中的代码，表示开启Gradle的增量编译，增加编译的内存到4G。"></a>gradle.properties文件中的代码，表示开启Gradle的多线程跟多核心支持。而build.gradle中的代码，表示开启Gradle的增量编译，增加编译的内存到4G。</h5><ol>
<li><p>增加编译内存</p>
<h5 id="对于编译时的内存溢出问题，我们可以在gradle-properties文件中增加一下内存配置，让Gradle获取更多内存。一般来说使用默认的即可。"><a href="#对于编译时的内存溢出问题，我们可以在gradle-properties文件中增加一下内存配置，让Gradle获取更多内存。一般来说使用默认的即可。" class="headerlink" title="对于编译时的内存溢出问题，我们可以在gradle.properties文件中增加一下内存配置，让Gradle获取更多内存。一般来说使用默认的即可。"></a>对于编译时的内存溢出问题，我们可以在gradle.properties文件中增加一下内存配置，让Gradle获取更多内存。一般来说使用默认的即可。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">org.gradle.jvmargs=-Xmx1536m</div></pre></td></tr></table></figure>
</li>
<li><p>使用Gradle精简资源</p>
<h5 id="前面我们提到了minifyEnabled指令，这个指令不仅可以用于混淆，也可以对代码进行优化、精简。同时配合shrinkResources指令，还可以清楚醒目中的无效的资源文件，但是要注意一点的是，shrinkResources指令依赖于minifyEnabled指令，只有后者开启了，前者才起作用，代码如下："><a href="#前面我们提到了minifyEnabled指令，这个指令不仅可以用于混淆，也可以对代码进行优化、精简。同时配合shrinkResources指令，还可以清楚醒目中的无效的资源文件，但是要注意一点的是，shrinkResources指令依赖于minifyEnabled指令，只有后者开启了，前者才起作用，代码如下：" class="headerlink" title="前面我们提到了minifyEnabled指令，这个指令不仅可以用于混淆，也可以对代码进行优化、精简。同时配合shrinkResources指令，还可以清楚醒目中的无效的资源文件，但是要注意一点的是，shrinkResources指令依赖于minifyEnabled指令，只有后者开启了，前者才起作用，代码如下："></a>前面我们提到了minifyEnabled指令，这个指令不仅可以用于混淆，也可以对代码进行优化、精简。同时配合shrinkResources指令，还可以清楚醒目中的无效的资源文件，但是要注意一点的是，shrinkResources指令依赖于minifyEnabled指令，只有后者开启了，前者才起作用，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">release &#123;</div><div class="line">            minifyEnabled true</div><div class="line">	    shrinkResources true</div><div class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="这里要注意，这种精简资源的方式属于静态检测，一些动态加载的资源是无法检测的。"><a href="#这里要注意，这种精简资源的方式属于静态检测，一些动态加载的资源是无法检测的。" class="headerlink" title="这里要注意，这种精简资源的方式属于静态检测，一些动态加载的资源是无法检测的。"></a>这里要注意，这种精简资源的方式属于静态检测，一些动态加载的资源是无法检测的。</h5><ol>
<li><p>清除Gradle缓存</p>
<h5 id="开发中经常遇到上传同一版本的aar到maven库，在主项目中无法获得最新的aar库的。这时候就需要将本地的Gradle缓存删除，让项目重新从Maven库中拉取最新的aar库。而在平时处理多使用gradle-clean指令来清理Gradle缓存以外，Gradle还提供了一个指令来重新刷新全部的依赖库—gradle-–refresh-dependencies-通过这个指令，可以强制刷新所依赖的库项目。"><a href="#开发中经常遇到上传同一版本的aar到maven库，在主项目中无法获得最新的aar库的。这时候就需要将本地的Gradle缓存删除，让项目重新从Maven库中拉取最新的aar库。而在平时处理多使用gradle-clean指令来清理Gradle缓存以外，Gradle还提供了一个指令来重新刷新全部的依赖库—gradle-–refresh-dependencies-通过这个指令，可以强制刷新所依赖的库项目。" class="headerlink" title="开发中经常遇到上传同一版本的aar到maven库，在主项目中无法获得最新的aar库的。这时候就需要将本地的Gradle缓存删除，让项目重新从Maven库中拉取最新的aar库。而在平时处理多使用gradle clean指令来清理Gradle缓存以外，Gradle还提供了一个指令来重新刷新全部的依赖库—gradle –refresh dependencies.通过这个指令，可以强制刷新所依赖的库项目。"></a>开发中经常遇到上传同一版本的aar到maven库，在主项目中无法获得最新的aar库的。这时候就需要将本地的Gradle缓存删除，让项目重新从Maven库中拉取最新的aar库。而在平时处理多使用gradle clean指令来清理Gradle缓存以外，Gradle还提供了一个指令来重新刷新全部的依赖库—gradle –refresh dependencies.通过这个指令，可以强制刷新所依赖的库项目。</h5></li>
<li><p>Gradle版本问题导致的编译失败</p>
<h5 id="开发这经常在会遇到Gradle-Version-导致的问题，通常这个问题是由gradle-wrapper导致的，要解决这个问题，只需要按照一下步骤进行检查即可。"><a href="#开发这经常在会遇到Gradle-Version-导致的问题，通常这个问题是由gradle-wrapper导致的，要解决这个问题，只需要按照一下步骤进行检查即可。" class="headerlink" title="开发这经常在会遇到Gradle Version 导致的问题，通常这个问题是由gradle wrapper导致的，要解决这个问题，只需要按照一下步骤进行检查即可。"></a>开发这经常在会遇到Gradle Version 导致的问题，通常这个问题是由gradle wrapper导致的，要解决这个问题，只需要按照一下步骤进行检查即可。</h5><h5 id="a-打开Setting界面，在Build-Build-Tools-Gradle标签中，选择Project-Level-settiong-并勾选Use-default-gradle-wrapper"><a href="#a-打开Setting界面，在Build-Build-Tools-Gradle标签中，选择Project-Level-settiong-并勾选Use-default-gradle-wrapper" class="headerlink" title="a. 打开Setting界面，在Build-Build Tools-Gradle标签中，选择Project-Level-settiong,并勾选Use default gradle wrapper."></a>a. 打开Setting界面，在Build-Build Tools-Gradle标签中，选择Project-Level-settiong,并勾选Use default gradle wrapper.</h5><h5 id="b-使用当前版本的AS创建一个空的Android工程并进行编译运行，目的是让Android-Studio拉取可能新增的依赖包。"><a href="#b-使用当前版本的AS创建一个空的Android工程并进行编译运行，目的是让Android-Studio拉取可能新增的依赖包。" class="headerlink" title="b. 使用当前版本的AS创建一个空的Android工程并进行编译运行，目的是让Android Studio拉取可能新增的依赖包。"></a>b. 使用当前版本的AS创建一个空的Android工程并进行编译运行，目的是让Android Studio拉取可能新增的依赖包。</h5><h5 id="c-复制刚刚创建的Android工程的Gradle目录，病粘贴到发生错误的工程中，替换原有的Gradle目录。"><a href="#c-复制刚刚创建的Android工程的Gradle目录，病粘贴到发生错误的工程中，替换原有的Gradle目录。" class="headerlink" title="c. 复制刚刚创建的Android工程的Gradle目录，病粘贴到发生错误的工程中，替换原有的Gradle目录。"></a>c. 复制刚刚创建的Android工程的Gradle目录，病粘贴到发生错误的工程中，替换原有的Gradle目录。</h5><h5 id="d-检查根目录下的build-gradle文件，检查Gradle的plugin版本，最好与空的Android工程中的plugin版本相同。"><a href="#d-检查根目录下的build-gradle文件，检查Gradle的plugin版本，最好与空的Android工程中的plugin版本相同。" class="headerlink" title="d. 检查根目录下的build.gradle文件，检查Gradle的plugin版本，最好与空的Android工程中的plugin版本相同。"></a>d. 检查根目录下的build.gradle文件，检查Gradle的plugin版本，最好与空的Android工程中的plugin版本相同。</h5><h5 id="执行完上边的步骤，在编译工程，基本都会解决该问题。不过我们更推荐在本地配置稳定的Gradle版本。"><a href="#执行完上边的步骤，在编译工程，基本都会解决该问题。不过我们更推荐在本地配置稳定的Gradle版本。" class="headerlink" title="执行完上边的步骤，在编译工程，基本都会解决该问题。不过我们更推荐在本地配置稳定的Gradle版本。"></a>执行完上边的步骤，在编译工程，基本都会解决该问题。不过我们更推荐在本地配置稳定的Gradle版本。</h5></li>
</ol>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><h5 id="关于Gradle我们就总结到这里，相信这些掌握了这些技巧已经能够应对日常开发了，当然如果你还想更深入的研究Gradle等，就需要自己查找官网或者其他书籍等来学习了。"><a href="#关于Gradle我们就总结到这里，相信这些掌握了这些技巧已经能够应对日常开发了，当然如果你还想更深入的研究Gradle等，就需要自己查找官网或者其他书籍等来学习了。" class="headerlink" title="关于Gradle我们就总结到这里，相信这些掌握了这些技巧已经能够应对日常开发了，当然如果你还想更深入的研究Gradle等，就需要自己查找官网或者其他书籍等来学习了。"></a>关于Gradle我们就总结到这里，相信这些掌握了这些技巧已经能够应对日常开发了，当然如果你还想更深入的研究Gradle等，就需要自己查找官网或者其他书籍等来学习了。</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.coolcoolcoder.com/c_night/2017/11/04/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoolYellow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coolyellow的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/04/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-04T23:37:29+08:00">
                2017-11-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.coolcoolcoder.com/c_night/2017/11/04/Gradle多项目依赖/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoolYellow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coolyellow的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/04/Gradle多项目依赖/" itemprop="url">Gradle多项目依赖</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-04T22:06:47+08:00">
                2017-11-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h5 id="经常情况下，一个Android项目不会只有一个主项目，通常会添加一些jar包或者Android库项目。如果使用jar包则无法带有资源，而如果使用Android库项目则必须要以源码形式进行依赖，这样不利于版本控制跟迭代开发。Android-studio提供了一种新的依赖方式aar。通过aar引用，既可以像引用jar包一样方便也可以携带资源，相当于封装了一套完整的源码。对于依赖jar包跟Android库项目想必大家都很熟悉了，这里就不再叙述了，只是总结一下注意的问题。"><a href="#经常情况下，一个Android项目不会只有一个主项目，通常会添加一些jar包或者Android库项目。如果使用jar包则无法带有资源，而如果使用Android库项目则必须要以源码形式进行依赖，这样不利于版本控制跟迭代开发。Android-studio提供了一种新的依赖方式aar。通过aar引用，既可以像引用jar包一样方便也可以携带资源，相当于封装了一套完整的源码。对于依赖jar包跟Android库项目想必大家都很熟悉了，这里就不再叙述了，只是总结一下注意的问题。" class="headerlink" title="经常情况下，一个Android项目不会只有一个主项目，通常会添加一些jar包或者Android库项目。如果使用jar包则无法带有资源，而如果使用Android库项目则必须要以源码形式进行依赖，这样不利于版本控制跟迭代开发。Android studio提供了一种新的依赖方式aar。通过aar引用，既可以像引用jar包一样方便也可以携带资源，相当于封装了一套完整的源码。对于依赖jar包跟Android库项目想必大家都很熟悉了，这里就不再叙述了，只是总结一下注意的问题。"></a>经常情况下，一个Android项目不会只有一个主项目，通常会添加一些jar包或者Android库项目。如果使用jar包则无法带有资源，而如果使用Android库项目则必须要以源码形式进行依赖，这样不利于版本控制跟迭代开发。Android studio提供了一种新的依赖方式aar。通过aar引用，既可以像引用jar包一样方便也可以携带资源，相当于封装了一套完整的源码。对于依赖jar包跟Android库项目想必大家都很熟悉了，这里就不再叙述了，只是总结一下注意的问题。</h5><h2 id="二、注意的问题"><a href="#二、注意的问题" class="headerlink" title="二、注意的问题"></a>二、注意的问题</h2><ol>
<li>关于jar包依赖重复的管理<h5 id="使用jar包有一个非常严重的问题，就是jar包的版本非常容易乱。如果两个module引用了同一个jar包，但是不同版本，那么Android-studio在编译的时候就会发生问题。因为它不知道该使用哪一个版本，因此使用jar包依赖，最好把所有重复使用到的jar包放到主module中。"><a href="#使用jar包有一个非常严重的问题，就是jar包的版本非常容易乱。如果两个module引用了同一个jar包，但是不同版本，那么Android-studio在编译的时候就会发生问题。因为它不知道该使用哪一个版本，因此使用jar包依赖，最好把所有重复使用到的jar包放到主module中。" class="headerlink" title="使用jar包有一个非常严重的问题，就是jar包的版本非常容易乱。如果两个module引用了同一个jar包，但是不同版本，那么Android studio在编译的时候就会发生问题。因为它不知道该使用哪一个版本，因此使用jar包依赖，最好把所有重复使用到的jar包放到主module中。"></a>使用jar包有一个非常严重的问题，就是jar包的版本非常容易乱。如果两个module引用了同一个jar包，但是不同版本，那么Android studio在编译的时候就会发生问题。因为它不知道该使用哪一个版本，因此使用jar包依赖，最好把所有重复使用到的jar包放到主module中。</h5></li>
<li>添加远程仓库依赖<h5 id="除了引用本地的依赖库，Gradle还支持以aar形式依赖远程服务器上的库项目。打开项目根目录下的build-gradle，代码如下："><a href="#除了引用本地的依赖库，Gradle还支持以aar形式依赖远程服务器上的库项目。打开项目根目录下的build-gradle，代码如下：" class="headerlink" title="除了引用本地的依赖库，Gradle还支持以aar形式依赖远程服务器上的库项目。打开项目根目录下的build.gradle，代码如下："></a>除了引用本地的依赖库，Gradle还支持以aar形式依赖远程服务器上的库项目。打开项目根目录下的build.gradle，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Top-level build file where you can add configuration options common to all sub-projects/modules.</div><div class="line"></div><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:2.3.3&apos;</div><div class="line"></div><div class="line">        // NOTE: Do not place your application dependencies here; they belong</div><div class="line">        // in the individual module build.gradle files</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    ext&#123;</div><div class="line">        VERSION_SDK = 25</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="在buildscript跟allprojects领域中，通过repositories指定要引用的远程仓库。其中默认的jcenter仓库是默认的远程仓库，你可以自己再添加别的仓库，比如mavenCentral。当jcenter仓库找不到时就会从mavenCentral中继续寻找。"><a href="#在buildscript跟allprojects领域中，通过repositories指定要引用的远程仓库。其中默认的jcenter仓库是默认的远程仓库，你可以自己再添加别的仓库，比如mavenCentral。当jcenter仓库找不到时就会从mavenCentral中继续寻找。" class="headerlink" title="在buildscript跟allprojects领域中，通过repositories指定要引用的远程仓库。其中默认的jcenter仓库是默认的远程仓库，你可以自己再添加别的仓库，比如mavenCentral。当jcenter仓库找不到时就会从mavenCentral中继续寻找。"></a>在buildscript跟allprojects领域中，通过repositories指定要引用的远程仓库。其中默认的jcenter仓库是默认的远程仓库，你可以自己再添加别的仓库，比如mavenCentral。当jcenter仓库找不到时就会从mavenCentral中继续寻找。</h5><ol>
<li>引用本地服务器中央库<h5 id="中央库是开放开源的，所以有很多公司自己内部使用的库不会放到中央库上的，因此很多公司需要搭建自己内部的中央库，即本地的Maven库。Gradle也是支持本地中央库的，只需要稍微修改代码即可："><a href="#中央库是开放开源的，所以有很多公司自己内部使用的库不会放到中央库上的，因此很多公司需要搭建自己内部的中央库，即本地的Maven库。Gradle也是支持本地中央库的，只需要稍微修改代码即可：" class="headerlink" title="中央库是开放开源的，所以有很多公司自己内部使用的库不会放到中央库上的，因此很多公司需要搭建自己内部的中央库，即本地的Maven库。Gradle也是支持本地中央库的，只需要稍微修改代码即可："></a>中央库是开放开源的，所以有很多公司自己内部使用的库不会放到中央库上的，因此很多公司需要搭建自己内部的中央库，即本地的Maven库。Gradle也是支持本地中央库的，只需要稍微修改代码即可：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Top-level build file where you can add configuration options common to all sub-projects/modules.</div><div class="line"></div><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">       mavenLocal()//优先使用本地库</div><div class="line">	maven&#123;</div><div class="line">		url myMaven</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:2.3.3&apos;</div><div class="line"></div><div class="line">        // NOTE: Do not place your application dependencies here; they belong</div><div class="line">        // in the individual module build.gradle files</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">         mavenLocal()//优先使用本地库</div><div class="line">	maven&#123;</div><div class="line">		url &quot;http://...&quot;</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="将mavenCentral、jcenter修改为mavenLocal，同时指定本地maven库地址，地址可以直接指定字符串，也可以通过变量的形式指定。"><a href="#将mavenCentral、jcenter修改为mavenLocal，同时指定本地maven库地址，地址可以直接指定字符串，也可以通过变量的形式指定。" class="headerlink" title="将mavenCentral、jcenter修改为mavenLocal，同时指定本地maven库地址，地址可以直接指定字符串，也可以通过变量的形式指定。"></a>将mavenCentral、jcenter修改为mavenLocal，同时指定本地maven库地址，地址可以直接指定字符串，也可以通过变量的形式指定。</h5><ol>
<li>本地aar依赖<h5 id="上面我们提到了aar依赖，相对一module来说使用aar效率更高，避免了执行gradle-build时对module的编译打包。当开发者对module进行编译后，在他的module-build-outputs-aar-目录下，会生成相应的aar文件。这个就是编译后生成的本地aar文件，如果需要在另一个项目中使用这个本地aar文件，只需要在主项目中有点选择new-new-module，并选择import-aar-packages即可。选好相应的aar文件后，再导入成功后，就可以想使用module一样使用本地aar库了。"><a href="#上面我们提到了aar依赖，相对一module来说使用aar效率更高，避免了执行gradle-build时对module的编译打包。当开发者对module进行编译后，在他的module-build-outputs-aar-目录下，会生成相应的aar文件。这个就是编译后生成的本地aar文件，如果需要在另一个项目中使用这个本地aar文件，只需要在主项目中有点选择new-new-module，并选择import-aar-packages即可。选好相应的aar文件后，再导入成功后，就可以想使用module一样使用本地aar库了。" class="headerlink" title="上面我们提到了aar依赖，相对一module来说使用aar效率更高，避免了执行gradle build时对module的编译打包。当开发者对module进行编译后，在他的module/build/outputs/aar/目录下，会生成相应的aar文件。这个就是编译后生成的本地aar文件，如果需要在另一个项目中使用这个本地aar文件，只需要在主项目中有点选择new-new module，并选择import .aar packages即可。选好相应的aar文件后，再导入成功后，就可以想使用module一样使用本地aar库了。"></a>上面我们提到了aar依赖，相对一module来说使用aar效率更高，避免了执行gradle build时对module的编译打包。当开发者对module进行编译后，在他的module/build/outputs/aar/目录下，会生成相应的aar文件。这个就是编译后生成的本地aar文件，如果需要在另一个项目中使用这个本地aar文件，只需要在主项目中有点选择new-new module，并选择import .aar packages即可。选好相应的aar文件后，再导入成功后，就可以想使用module一样使用本地aar库了。</h5><h2 id="三、Gradle依赖管理"><a href="#三、Gradle依赖管理" class="headerlink" title="三、Gradle依赖管理"></a>三、Gradle依赖管理</h2></li>
<li>利用Gradle的依赖检查<h5 id="实际上，利用Gradle提供的task可以很方便的解决依赖问题-用到Gradle指令就是gradle-androidDependencies-通过这个指令，可以很方便的找到梅总buildType下的依赖关系图。这样当某个依赖发生变更的时候，就可以通过这个task检查每个项目下是否包含该依赖库的引用。如果有则需要提示开发者进行更新，而且这一切都可以使用python脚本进行自动化。"><a href="#实际上，利用Gradle提供的task可以很方便的解决依赖问题-用到Gradle指令就是gradle-androidDependencies-通过这个指令，可以很方便的找到梅总buildType下的依赖关系图。这样当某个依赖发生变更的时候，就可以通过这个task检查每个项目下是否包含该依赖库的引用。如果有则需要提示开发者进行更新，而且这一切都可以使用python脚本进行自动化。" class="headerlink" title="实际上，利用Gradle提供的task可以很方便的解决依赖问题,用到Gradle指令就是gradle androidDependencies,通过这个指令，可以很方便的找到梅总buildType下的依赖关系图。这样当某个依赖发生变更的时候，就可以通过这个task检查每个项目下是否包含该依赖库的引用。如果有则需要提示开发者进行更新，而且这一切都可以使用python脚本进行自动化。"></a>实际上，利用Gradle提供的task可以很方便的解决依赖问题,用到Gradle指令就是gradle androidDependencies,通过这个指令，可以很方便的找到梅总buildType下的依赖关系图。这样当某个依赖发生变更的时候，就可以通过这个task检查每个项目下是否包含该依赖库的引用。如果有则需要提示开发者进行更新，而且这一切都可以使用python脚本进行自动化。</h5></li>
<li>Gradle依赖传递<h5 id="在使用Gradle-aar文件时，往往会遇到依赖传递的问题，如果不想依赖进行传递则可以在原依赖后加入-aar关键子关闭依赖传递"><a href="#在使用Gradle-aar文件时，往往会遇到依赖传递的问题，如果不想依赖进行传递则可以在原依赖后加入-aar关键子关闭依赖传递" class="headerlink" title="在使用Gradle aar文件时，往往会遇到依赖传递的问题，如果不想依赖进行传递则可以在原依赖后加入@aar关键子关闭依赖传递"></a>在使用Gradle aar文件时，往往会遇到依赖传递的问题，如果不想依赖进行传递则可以在原依赖后加入@aar关键子关闭依赖传递</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.xxxxxxxx-xyz&apos;//原依赖</div><div class="line">compile &apos;com.xxxxxxxx-xyz@aar&apos;//关闭依赖传递后</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="但是这种不适用libs目录下的jar问价，开发者使用时要非常注意。另外还可以使用exclude-module排除一个库中引用的其他库，例如aar库A引用了B跟C，，此时可以通过如下方式进行依赖"><a href="#但是这种不适用libs目录下的jar问价，开发者使用时要非常注意。另外还可以使用exclude-module排除一个库中引用的其他库，例如aar库A引用了B跟C，，此时可以通过如下方式进行依赖" class="headerlink" title="但是这种不适用libs目录下的jar问价，开发者使用时要非常注意。另外还可以使用exclude module排除一个库中引用的其他库，例如aar库A引用了B跟C，，此时可以通过如下方式进行依赖"></a>但是这种不适用libs目录下的jar问价，开发者使用时要非常注意。另外还可以使用exclude module排除一个库中引用的其他库，例如aar库A引用了B跟C，，此时可以通过如下方式进行依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile(&apos;com.xxxxxx.xyz&apos;)&#123;</div><div class="line">	exclude module:&apos;com.xxx.bbb&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="这样也可以在A库中去除B跟C的依赖。"><a href="#这样也可以在A库中去除B跟C的依赖。" class="headerlink" title="这样也可以在A库中去除B跟C的依赖。"></a>这样也可以在A库中去除B跟C的依赖。</h5><h2 id="四、Gradle统一管理"><a href="#四、Gradle统一管理" class="headerlink" title="四、Gradle统一管理"></a>四、Gradle统一管理</h2><h5 id="Gradle引用依赖非常简单，但一旦涉及多module，每个module的依赖管理就变得非常麻烦了，就跟编程中使用的变量一样，每个module中的依赖—局部变量，这样就造成了多module有多个相同的局部变量，不利于项目管理，因此最好是类似于全局变量一样的方式来统一管理-利用前文介绍的Gradle全局变量就可以非常容易的实现这一管理，在根目录的build-gradle脚本进行如下配置："><a href="#Gradle引用依赖非常简单，但一旦涉及多module，每个module的依赖管理就变得非常麻烦了，就跟编程中使用的变量一样，每个module中的依赖—局部变量，这样就造成了多module有多个相同的局部变量，不利于项目管理，因此最好是类似于全局变量一样的方式来统一管理-利用前文介绍的Gradle全局变量就可以非常容易的实现这一管理，在根目录的build-gradle脚本进行如下配置：" class="headerlink" title="Gradle引用依赖非常简单，但一旦涉及多module，每个module的依赖管理就变得非常麻烦了，就跟编程中使用的变量一样，每个module中的依赖—局部变量，这样就造成了多module有多个相同的局部变量，不利于项目管理，因此最好是类似于全局变量一样的方式来统一管理,利用前文介绍的Gradle全局变量就可以非常容易的实现这一管理，在根目录的build.gradle脚本进行如下配置："></a>Gradle引用依赖非常简单，但一旦涉及多module，每个module的依赖管理就变得非常麻烦了，就跟编程中使用的变量一样，每个module中的依赖—局部变量，这样就造成了多module有多个相同的局部变量，不利于项目管理，因此最好是类似于全局变量一样的方式来统一管理,利用前文介绍的Gradle全局变量就可以非常容易的实现这一管理，在根目录的build.gradle脚本进行如下配置：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ext &#123;</div><div class="line">	dependencies = [support7:&apos;com.xxxxx.xyz&apos;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="这样我们在每个module中，可以通过代码使用全局的依赖配置，代码如下："><a href="#这样我们在每个module中，可以通过代码使用全局的依赖配置，代码如下：" class="headerlink" title="这样我们在每个module中，可以通过代码使用全局的依赖配置，代码如下："></a>这样我们在每个module中，可以通过代码使用全局的依赖配置，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">	compile rootProject.ext.dependencies.support7</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="通过这种方式，可以使用全局变量统一管理这些依赖配置。更进一步，开发者还可以把这些配置，统一提取到一个单独的配置文件中，例如，我们在项目根目录下创建一个config-gradle文件，并写入如下所示代码："><a href="#通过这种方式，可以使用全局变量统一管理这些依赖配置。更进一步，开发者还可以把这些配置，统一提取到一个单独的配置文件中，例如，我们在项目根目录下创建一个config-gradle文件，并写入如下所示代码：" class="headerlink" title="通过这种方式，可以使用全局变量统一管理这些依赖配置。更进一步，开发者还可以把这些配置，统一提取到一个单独的配置文件中，例如，我们在项目根目录下创建一个config.gradle文件，并写入如下所示代码："></a>通过这种方式，可以使用全局变量统一管理这些依赖配置。更进一步，开发者还可以把这些配置，统一提取到一个单独的配置文件中，例如，我们在项目根目录下创建一个config.gradle文件，并写入如下所示代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ext &#123;</div><div class="line">	dependencies = [support7:&apos;com.xxxxx.xyz&apos;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="这样我们就需要在根目录下的build-gradle文件中，使用代码加载这个配置文件，代码如下："><a href="#这样我们就需要在根目录下的build-gradle文件中，使用代码加载这个配置文件，代码如下：" class="headerlink" title="这样我们就需要在根目录下的build.gradle文件中，使用代码加载这个配置文件，代码如下："></a>这样我们就需要在根目录下的build.gradle文件中，使用代码加载这个配置文件，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply from:&apos;config.gradle&apos;</div></pre></td></tr></table></figure>
<h5 id="这样就可以在所有的module中引用这些参数了，使用方式跟前面的方式相同。"><a href="#这样就可以在所有的module中引用这些参数了，使用方式跟前面的方式相同。" class="headerlink" title="这样就可以在所有的module中引用这些参数了，使用方式跟前面的方式相同。"></a>这样就可以在所有的module中引用这些参数了，使用方式跟前面的方式相同。</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.coolcoolcoder.com/c_night/2017/10/26/Gradle之进阶-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoolYellow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coolyellow的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/Gradle之进阶-2/" itemprop="url">Gradle之进阶-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T22:09:53+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h5 id="上一节我们讲解了部分gradle进阶的用法，这一节我们继续讲解gradle进阶。"><a href="#上一节我们讲解了部分gradle进阶的用法，这一节我们继续讲解gradle进阶。" class="headerlink" title="上一节我们讲解了部分gradle进阶的用法，这一节我们继续讲解gradle进阶。"></a>上一节我们讲解了部分gradle进阶的用法，这一节我们继续讲解gradle进阶。</h5><h2 id="二构建Proguard"><a href="#二构建Proguard" class="headerlink" title="二构建Proguard"></a>二构建Proguard</h2><h5 id="Proguard配置是Android的apk混淆文件配置，但它的作用绝对仅仅是混淆代码。它同样可以精简代码、资源，优化代码结构。所以新版studio中，google将runProguard的参数名改为了minifyEnabled，更加直白的显示了它的作用。它的配置也非常简单，在构建类型中直接配置参数启用即可，代码如下："><a href="#Proguard配置是Android的apk混淆文件配置，但它的作用绝对仅仅是混淆代码。它同样可以精简代码、资源，优化代码结构。所以新版studio中，google将runProguard的参数名改为了minifyEnabled，更加直白的显示了它的作用。它的配置也非常简单，在构建类型中直接配置参数启用即可，代码如下：" class="headerlink" title="Proguard配置是Android的apk混淆文件配置，但它的作用绝对仅仅是混淆代码。它同样可以精简代码、资源，优化代码结构。所以新版studio中，google将runProguard的参数名改为了minifyEnabled，更加直白的显示了它的作用。它的配置也非常简单，在构建类型中直接配置参数启用即可，代码如下："></a>Proguard配置是Android的apk混淆文件配置，但它的作用绝对仅仅是混淆代码。它同样可以精简代码、资源，优化代码结构。所以新版studio中，google将runProguard的参数名改为了minifyEnabled，更加直白的显示了它的作用。它的配置也非常简单，在构建类型中直接配置参数启用即可，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line">       release &#123;</div><div class="line">           minifyEnabled false</div><div class="line">           proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="这样在构建release版本时，系统就会自动进行混淆，而混淆配置文件的地址，则通过getDefaultProguardFile方法来获取。SDK默认的混淆文件配置模板，在SDK的tool-proguard目录下可以找到。"><a href="#这样在构建release版本时，系统就会自动进行混淆，而混淆配置文件的地址，则通过getDefaultProguardFile方法来获取。SDK默认的混淆文件配置模板，在SDK的tool-proguard目录下可以找到。" class="headerlink" title="这样在构建release版本时，系统就会自动进行混淆，而混淆配置文件的地址，则通过getDefaultProguardFile方法来获取。SDK默认的混淆文件配置模板，在SDK的tool/proguard目录下可以找到。"></a>这样在构建release版本时，系统就会自动进行混淆，而混淆配置文件的地址，则通过getDefaultProguardFile方法来获取。SDK默认的混淆文件配置模板，在SDK的tool/proguard目录下可以找到。</h5><h2 id="三、Gradle动态参数配置"><a href="#三、Gradle动态参数配置" class="headerlink" title="三、Gradle动态参数配置"></a>三、Gradle动态参数配置</h2><h5 id="Gradle既然是一种脚本配置语言，那么就一定可以通过配置文件动态配置其编译脚本。那么如何进行脚本的动态配置呢？在gradle中提供了gradle-properties文件来配置脚本中的动态参数。"><a href="#Gradle既然是一种脚本配置语言，那么就一定可以通过配置文件动态配置其编译脚本。那么如何进行脚本的动态配置呢？在gradle中提供了gradle-properties文件来配置脚本中的动态参数。" class="headerlink" title="Gradle既然是一种脚本配置语言，那么就一定可以通过配置文件动态配置其编译脚本。那么如何进行脚本的动态配置呢？在gradle中提供了gradle.properties文件来配置脚本中的动态参数。"></a>Gradle既然是一种脚本配置语言，那么就一定可以通过配置文件动态配置其编译脚本。那么如何进行脚本的动态配置呢？在gradle中提供了gradle.properties文件来配置脚本中的动态参数。</h5><p>###（一）System.properties方式</p>
<h5 id="首先打开gradle-properties文件，添加如下配置："><a href="#首先打开gradle-properties文件，添加如下配置：" class="headerlink" title="首先打开gradle.properties文件，添加如下配置："></a>首先打开gradle.properties文件，添加如下配置：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">systemProp.keyAliasPassword=123456</div><div class="line">systemProp.keyALias=cool</div><div class="line">systemProp.keyStorePassword=123456</div><div class="line">systemProp.keyStore=cool.jks</div></pre></td></tr></table></figure>
<h5 id="然后在build-gradle脚本中进行引用的时候，就可以统统System-properties-key-获取这些参数，代码如下："><a href="#然后在build-gradle脚本中进行引用的时候，就可以统统System-properties-key-获取这些参数，代码如下：" class="headerlink" title="然后在build.gradle脚本中进行引用的时候，就可以统统System.properties[key]获取这些参数，代码如下："></a>然后在build.gradle脚本中进行引用的时候，就可以统统System.properties[key]获取这些参数，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">signingConfigs &#123;</div><div class="line">        cool &#123;</div><div class="line">            storeFile file(System.properties[&quot;keyStore&quot;])</div><div class="line">            storePassword System.properties[&quot;keyStorePassword&quot;]</div><div class="line">            keyAlias System.properties[&quot;keyAlias&quot;]</div><div class="line">            keyPassword System.properties[&quot;keyALiasPassword&quot;]</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="二-Key-Value方式"><a href="#二-Key-Value方式" class="headerlink" title="(二)Key\Value方式"></a>(二)Key\Value方式</h3><h5 id="除了使用System-properties方式获取自定义的配置参数之外，还可以使用Key-Value方式来定义。在gradle-properties文件中，添加如下代码："><a href="#除了使用System-properties方式获取自定义的配置参数之外，还可以使用Key-Value方式来定义。在gradle-properties文件中，添加如下代码：" class="headerlink" title="除了使用System.properties方式获取自定义的配置参数之外，还可以使用Key\Value方式来定义。在gradle.properties文件中，添加如下代码："></a>除了使用System.properties方式获取自定义的配置参数之外，还可以使用Key\Value方式来定义。在gradle.properties文件中，添加如下代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cool.keyAlias=cool</div><div class="line">cool.keyALiasPassword=123456</div></pre></td></tr></table></figure>
<h5 id="然后在build-gradle中进行引用"><a href="#然后在build-gradle中进行引用" class="headerlink" title="然后在build.gradle中进行引用"></a>然后在build.gradle中进行引用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">signingConfigs &#123;</div><div class="line">        cool &#123;</div><div class="line">            storeFile file(System.properties[&quot;keyStore&quot;])</div><div class="line">            storePassword System.properties[&quot;keyStorePassword&quot;]</div><div class="line"></div><div class="line">            keyAlias project.property(&quot;coo.keyAlias&quot;)</div><div class="line">            keyPassword project.property(&quot;coo.keyAliasPassword&quot;)</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h5 id="通过project-property-key-方法，就可以取出对应的value，这种方式与使用System-properties的方式一样，所以可以根据情况使用任意一种即可。"><a href="#通过project-property-key-方法，就可以取出对应的value，这种方式与使用System-properties的方式一样，所以可以根据情况使用任意一种即可。" class="headerlink" title="通过project.property(key)方法，就可以取出对应的value，这种方式与使用System.properties的方式一样，所以可以根据情况使用任意一种即可。"></a>通过project.property(key)方法，就可以取出对应的value，这种方式与使用System.properties的方式一样，所以可以根据情况使用任意一种即可。</h5><h3 id="（三）属性方式"><a href="#（三）属性方式" class="headerlink" title="（三）属性方式"></a>（三）属性方式</h3><h5 id="前面两种方式，均可以在命令行中设置参数，从而设置给编译命令。如果不需要在命令行中设置参数，那么直接写属性名，同样可以引用，代码如下："><a href="#前面两种方式，均可以在命令行中设置参数，从而设置给编译命令。如果不需要在命令行中设置参数，那么直接写属性名，同样可以引用，代码如下：" class="headerlink" title="前面两种方式，均可以在命令行中设置参数，从而设置给编译命令。如果不需要在命令行中设置参数，那么直接写属性名，同样可以引用，代码如下："></a>前面两种方式，均可以在命令行中设置参数，从而设置给编译命令。如果不需要在命令行中设置参数，那么直接写属性名，同样可以引用，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">coolKeyALias=cool</div><div class="line">coolKeyAliasPassword=123456</div></pre></td></tr></table></figure>
<h5 id="这样在build-gradle脚本中就可以直接引用了，代码如下："><a href="#这样在build-gradle脚本中就可以直接引用了，代码如下：" class="headerlink" title="这样在build.gradle脚本中就可以直接引用了，代码如下："></a>这样在build.gradle脚本中就可以直接引用了，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">signingConfigs &#123;</div><div class="line">        cool &#123;</div><div class="line">            storeFile file(System.properties[&quot;keyStore&quot;])</div><div class="line">            storePassword System.properties[&quot;keyStorePassword&quot;]</div><div class="line"></div><div class="line">           // keyAlias project.property(&quot;coo.keyAlias&quot;)</div><div class="line">           // keyPassword project.property(&quot;coo.keyAliasPassword&quot;)</div><div class="line"></div><div class="line">	   keyAlias coolKeyALias</div><div class="line">           keyPassword coolKeyAliasPassword</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="这样设置的效果与前面两种一样，区别就是是否支持命令行配置参数。"><a href="#这样设置的效果与前面两种一样，区别就是是否支持命令行配置参数。" class="headerlink" title="这样设置的效果与前面两种一样，区别就是是否支持命令行配置参数。"></a>这样设置的效果与前面两种一样，区别就是是否支持命令行配置参数。</h5><h2 id="四、多渠道打包"><a href="#四、多渠道打包" class="headerlink" title="四、多渠道打包"></a>四、多渠道打包</h2><h5 id="多渠道打包其实就是在代码层上标记不同的渠道名，这样便于统计不同的应用市场该apk的下载量。利用Gradle打包，将开发者从之间繁杂的ant打包中解救出来，我们只需要在Gradle中进行简单配置即可。"><a href="#多渠道打包其实就是在代码层上标记不同的渠道名，这样便于统计不同的应用市场该apk的下载量。利用Gradle打包，将开发者从之间繁杂的ant打包中解救出来，我们只需要在Gradle中进行简单配置即可。" class="headerlink" title="多渠道打包其实就是在代码层上标记不同的渠道名，这样便于统计不同的应用市场该apk的下载量。利用Gradle打包，将开发者从之间繁杂的ant打包中解救出来，我们只需要在Gradle中进行简单配置即可。"></a>多渠道打包其实就是在代码层上标记不同的渠道名，这样便于统计不同的应用市场该apk的下载量。利用Gradle打包，将开发者从之间繁杂的ant打包中解救出来，我们只需要在Gradle中进行简单配置即可。</h5><h3 id="一-创建渠道占位符"><a href="#一-创建渠道占位符" class="headerlink" title="(一)创建渠道占位符"></a>(一)创建渠道占位符</h3><h5 id="首先在AndraoidManifest文件的Application节点下，创建如下所示的meta-data节点。"><a href="#首先在AndraoidManifest文件的Application节点下，创建如下所示的meta-data节点。" class="headerlink" title="首先在AndraoidManifest文件的Application节点下，创建如下所示的meta-data节点。"></a>首先在AndraoidManifest文件的Application节点下，创建如下所示的meta-data节点。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;meta-data</div><div class="line">	android:name=&quot;COOLTEST&quot;</div><div class="line">	android:value=&quot;$&#123;COOL_VALUE&#125;&quot;/&gt;</div></pre></td></tr></table></figure>
<h5 id="其中-COOL-VALUE-就是要进行替换的渠道占位符。"><a href="#其中-COOL-VALUE-就是要进行替换的渠道占位符。" class="headerlink" title="其中${COOL_VALUE}就是要进行替换的渠道占位符。"></a>其中${COOL_VALUE}就是要进行替换的渠道占位符。</h5><h3 id="（二）配置Gradle脚本"><a href="#（二）配置Gradle脚本" class="headerlink" title="（二）配置Gradle脚本"></a>（二）配置Gradle脚本</h3><h5 id="在项目的Gradle脚本的android领域中，添加productFlavors领域，并添加定义的渠道名，同时使用manifestPlaceholders指定要替换渠道占位符的值，代码如下"><a href="#在项目的Gradle脚本的android领域中，添加productFlavors领域，并添加定义的渠道名，同时使用manifestPlaceholders指定要替换渠道占位符的值，代码如下" class="headerlink" title="在项目的Gradle脚本的android领域中，添加productFlavors领域，并添加定义的渠道名，同时使用manifestPlaceholders指定要替换渠道占位符的值，代码如下"></a>在项目的Gradle脚本的android领域中，添加productFlavors领域，并添加定义的渠道名，同时使用manifestPlaceholders指定要替换渠道占位符的值，代码如下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">	product1 &#123;</div><div class="line">		manifestPlaceholders=[COOL_VALUE:&quot;PRODUCT1&quot;]</div><div class="line">	&#125;</div><div class="line">	product2 &#123;</div><div class="line">		manifestPlaceholders=[COOL_VALUE:&quot;PRODUCT2&quot;]</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="这样我们就定义了两个不同的渠道—-product1、product2-每个渠道都将指定值赋值给渠道占位符。这样配置后，就完成了多渠道的打包工作。只需要在终端中执行gradle-build即可开始构建。"><a href="#这样我们就定义了两个不同的渠道—-product1、product2-每个渠道都将指定值赋值给渠道占位符。这样配置后，就完成了多渠道的打包工作。只需要在终端中执行gradle-build即可开始构建。" class="headerlink" title="这样我们就定义了两个不同的渠道—-product1、product2.每个渠道都将指定值赋值给渠道占位符。这样配置后，就完成了多渠道的打包工作。只需要在终端中执行gradle build即可开始构建。"></a>这样我们就定义了两个不同的渠道—-product1、product2.每个渠道都将指定值赋值给渠道占位符。这样配置后，就完成了多渠道的打包工作。只需要在终端中执行gradle build即可开始构建。</h5><h3 id="（三）脚本优化"><a href="#（三）脚本优化" class="headerlink" title="（三）脚本优化"></a>（三）脚本优化</h3><h5 id="对于上面的多渠道打包脚本，由于每个渠道的替换工作基本类似，因此我们可以对脚本进行以下优化。"><a href="#对于上面的多渠道打包脚本，由于每个渠道的替换工作基本类似，因此我们可以对脚本进行以下优化。" class="headerlink" title="对于上面的多渠道打包脚本，由于每个渠道的替换工作基本类似，因此我们可以对脚本进行以下优化。"></a>对于上面的多渠道打包脚本，由于每个渠道的替换工作基本类似，因此我们可以对脚本进行以下优化。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">	product1 &#123;</div><div class="line">		manifestPlaceholders=[COOL_VALUE:&quot;PRODUCT1&quot;]</div><div class="line">	&#125;</div><div class="line">	product2 &#123;</div><div class="line">		manifestPlaceholders=[COOL_VALUE:&quot;PRODUCT2&quot;]</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">productFLavors.all &#123; flavor-&gt;</div><div class="line">	flavor.manifestPlaceholders=[COOL_VALUE:name]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="增加了productFlavors-all领域对所有的productFlavors进行了遍历，并使用其那么作为渠道名。这些name实际就是product1-product2"><a href="#增加了productFlavors-all领域对所有的productFlavors进行了遍历，并使用其那么作为渠道名。这些name实际就是product1-product2" class="headerlink" title="增加了productFlavors.all领域对所有的productFlavors进行了遍历，并使用其那么作为渠道名。这些name实际就是product1,product2."></a>增加了productFlavors.all领域对所有的productFlavors进行了遍历，并使用其那么作为渠道名。这些name实际就是product1,product2.</h5><h3 id="（四）生成重命名包"><a href="#（四）生成重命名包" class="headerlink" title="（四）生成重命名包"></a>（四）生成重命名包</h3><h5 id="在生成渠道包后，包的命名通常都不会满足项目经理的要求。那么这时候就可以通过gradle脚本进行快速重命名，代码如下："><a href="#在生成渠道包后，包的命名通常都不会满足项目经理的要求。那么这时候就可以通过gradle脚本进行快速重命名，代码如下：" class="headerlink" title="在生成渠道包后，包的命名通常都不会满足项目经理的要求。那么这时候就可以通过gradle脚本进行快速重命名，代码如下："></a>在生成渠道包后，包的命名通常都不会满足项目经理的要求。那么这时候就可以通过gradle脚本进行快速重命名，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">	...</div><div class="line">	applicationVarians.all &#123; variant -&gt;</div><div class="line">	variant.outputs.each &#123; output -&gt;</div><div class="line">		if(output.outputFile!=null&amp;&amp;output.outputFile.name.endWith(&apos;.apk&apos;)&amp;&amp;</div><div class="line">		&apos;release&apos;.equals(variant.buildType.name))&#123;</div><div class="line">		def apkFile = new File(output.outputFile.getParent(),&quot;XXXApp_$&#123;variant.flavorNmae&#125;_ver$&#123;variant.versionName&#125;.apk&quot;)</div><div class="line">		aoutput.outputFile = apkFile</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="将这段代码放到android领域即可，当执行gradle-build指令时该task也会执行，代码含义很好理解，这里就不多说了。"><a href="#将这段代码放到android领域即可，当执行gradle-build指令时该task也会执行，代码含义很好理解，这里就不多说了。" class="headerlink" title="将这段代码放到android领域即可，当执行gradle build指令时该task也会执行，代码含义很好理解，这里就不多说了。"></a>将这段代码放到android领域即可，当执行gradle build指令时该task也会执行，代码含义很好理解，这里就不多说了。</h5><h3 id="五-为不同版本添加不同代码"><a href="#五-为不同版本添加不同代码" class="headerlink" title="(五)为不同版本添加不同代码"></a>(五)为不同版本添加不同代码</h3><h5 id="在开发中，不同版本通常有不同的代码功能，比如最常用的Log开关。因此，一般会有一个全局变量开关，根据不同版本设置不同的值。接下来我们就以buildType为例，为不同的buildType添加不同的参数配置，代码如下"><a href="#在开发中，不同版本通常有不同的代码功能，比如最常用的Log开关。因此，一般会有一个全局变量开关，根据不同版本设置不同的值。接下来我们就以buildType为例，为不同的buildType添加不同的参数配置，代码如下" class="headerlink" title="在开发中，不同版本通常有不同的代码功能，比如最常用的Log开关。因此，一般会有一个全局变量开关，根据不同版本设置不同的值。接下来我们就以buildType为例，为不同的buildType添加不同的参数配置，代码如下"></a>在开发中，不同版本通常有不同的代码功能，比如最常用的Log开关。因此，一般会有一个全局变量开关，根据不同版本设置不同的值。接下来我们就以buildType为例，为不同的buildType添加不同的参数配置，代码如下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line">       release &#123;</div><div class="line">           buildConfigField(&quot;boolean&quot;,&quot;test&quot;,&quot;true&quot;)</div><div class="line">           minifyEnabled false</div><div class="line">           proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">       &#125;</div><div class="line">       cool &#123;</div><div class="line">           buildConfigField(&quot;boolean&quot;,&quot;test&quot;,&quot;false&quot;)</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<h5 id="通过指定buildConfigField的三个参数—类型、名称、值，就可以将变量设置到不同的buildType中去。打开系统的BuildConfig类，可以看到不同的buildType下对应的flag值。然后我们直接使用BuildConfig类，就可以获取到不同的buildType所对应的值了。这里演示的是boolean类型的变量，如果是string类型的，在写入字符串时，需要加转移字符。"><a href="#通过指定buildConfigField的三个参数—类型、名称、值，就可以将变量设置到不同的buildType中去。打开系统的BuildConfig类，可以看到不同的buildType下对应的flag值。然后我们直接使用BuildConfig类，就可以获取到不同的buildType所对应的值了。这里演示的是boolean类型的变量，如果是string类型的，在写入字符串时，需要加转移字符。" class="headerlink" title="通过指定buildConfigField的三个参数—类型、名称、值，就可以将变量设置到不同的buildType中去。打开系统的BuildConfig类，可以看到不同的buildType下对应的flag值。然后我们直接使用BuildConfig类，就可以获取到不同的buildType所对应的值了。这里演示的是boolean类型的变量，如果是string类型的，在写入字符串时，需要加转移字符。"></a>通过指定buildConfigField的三个参数—类型、名称、值，就可以将变量设置到不同的buildType中去。打开系统的BuildConfig类，可以看到不同的buildType下对应的flag值。然后我们直接使用BuildConfig类，就可以获取到不同的buildType所对应的值了。这里演示的是boolean类型的变量，如果是string类型的，在写入字符串时，需要加转移字符。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">buildConfigField &quot;String&quot;,&quot;name&quot;,&quot;\&quot;coolyellow\&quot;&quot;</div></pre></td></tr></table></figure>
<h5 id="同时在设置变量的时候，甚至可以继续使用变量，代码如下："><a href="#同时在设置变量的时候，甚至可以继续使用变量，代码如下：" class="headerlink" title="同时在设置变量的时候，甚至可以继续使用变量，代码如下："></a>同时在设置变量的时候，甚至可以继续使用变量，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def param = ......</div><div class="line">buildConfigField &quot;String&quot;,&quot;name&quot;,&quot;\&quot;String.$&#123;param&#125;.String\&quot;&quot;</div></pre></td></tr></table></figure>
<h5 id="此外我们也可以使用资源文件进行分版本设置属性，例如要给不同版本设置不同的AppName，代码如下："><a href="#此外我们也可以使用资源文件进行分版本设置属性，例如要给不同版本设置不同的AppName，代码如下：" class="headerlink" title="此外我们也可以使用资源文件进行分版本设置属性，例如要给不同版本设置不同的AppName，代码如下："></a>此外我们也可以使用资源文件进行分版本设置属性，例如要给不同版本设置不同的AppName，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line">       release &#123;</div><div class="line">           resValue(&quot;string&quot;,&quot;appName&quot;,&quot;releaseApp&quot;)</div><div class="line">           minifyEnabled false</div><div class="line">           proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">       &#125;</div><div class="line">       cool &#123;</div><div class="line">	resValue(&quot;string&quot;,&quot;appName&quot;,&quot;coolApp&quot;)</div><div class="line">           buildConfigField(&quot;boolean&quot;,&quot;test&quot;,&quot;false&quot;)</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<h5 id="在代码中同样使用R-string-appName来获取，但是一定要注意要把string-xml中的appName删掉，这样才能编译通过。因为Gradle在编译过程中将会将脚本中的配置和string-xml文件中的配置进行merge操作，如果同时存在两份相同的属性值，就会发生冲突。"><a href="#在代码中同样使用R-string-appName来获取，但是一定要注意要把string-xml中的appName删掉，这样才能编译通过。因为Gradle在编译过程中将会将脚本中的配置和string-xml文件中的配置进行merge操作，如果同时存在两份相同的属性值，就会发生冲突。" class="headerlink" title="在代码中同样使用R.string.appName来获取，但是一定要注意要把string.xml中的appName删掉，这样才能编译通过。因为Gradle在编译过程中将会将脚本中的配置和string.xml文件中的配置进行merge操作，如果同时存在两份相同的属性值，就会发生冲突。"></a>在代码中同样使用R.string.appName来获取，但是一定要注意要把string.xml中的appName删掉，这样才能编译通过。因为Gradle在编译过程中将会将脚本中的配置和string.xml文件中的配置进行merge操作，如果同时存在两份相同的属性值，就会发生冲突。</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.coolcoolcoder.com/c_night/2017/10/22/Gradle之进阶-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoolYellow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coolyellow的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/22/Gradle之进阶-1/" itemprop="url">Gradle之进阶-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-22T16:56:40+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h5 id="上一节我们讲解了gradle的基本用法，这一节我们研究一下gradle的进阶方法。"><a href="#上一节我们讲解了gradle的基本用法，这一节我们研究一下gradle的进阶方法。" class="headerlink" title="上一节我们讲解了gradle的基本用法，这一节我们研究一下gradle的进阶方法。"></a>上一节我们讲解了gradle的基本用法，这一节我们研究一下gradle的进阶方法。</h5><h2 id="二、更改项目结构"><a href="#二、更改项目结构" class="headerlink" title="二、更改项目结构"></a>二、更改项目结构</h2><h5 id="Gradle提供了自定义项目目录结构的方法，在前面讲到的android领域中，可以配置Android项目相关的配置。如下所示："><a href="#Gradle提供了自定义项目目录结构的方法，在前面讲到的android领域中，可以配置Android项目相关的配置。如下所示：" class="headerlink" title="Gradle提供了自定义项目目录结构的方法，在前面讲到的android领域中，可以配置Android项目相关的配置。如下所示："></a>Gradle提供了自定义项目目录结构的方法，在前面讲到的android领域中，可以配置Android项目相关的配置。如下所示：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sourceSets &#123;</div><div class="line">	main &#123;</div><div class="line">		java.srcDirs=[&apos;java&apos;]</div><div class="line">		res.srcDirs=[&apos;res&apos;]</div><div class="line">		assets.srcDirs=[&apos;assets&apos;]</div><div class="line">		jni.srcDirs=[&apos;jni&apos;]</div><div class="line">		jniLibs.srcDirs=[&apos;libs&apos;]</div><div class="line">		manifest.srcFile=&apos;AndroidManifest.xml&apos;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h5 id="上面的代码相信大家都能看懂，只需要制定具体的Android所必须文件夹的路径，就等于告诉Gradle需要使用自定义目录结构，而不是使用默认项目结构。"><a href="#上面的代码相信大家都能看懂，只需要制定具体的Android所必须文件夹的路径，就等于告诉Gradle需要使用自定义目录结构，而不是使用默认项目结构。" class="headerlink" title="上面的代码相信大家都能看懂，只需要制定具体的Android所必须文件夹的路径，就等于告诉Gradle需要使用自定义目录结构，而不是使用默认项目结构。"></a>上面的代码相信大家都能看懂，只需要制定具体的Android所必须文件夹的路径，就等于告诉Gradle需要使用自定义目录结构，而不是使用默认项目结构。</h5><h4 id="通过sourceSets也可以完全自定义代码的目录结构便于代码的整理，例如："><a href="#通过sourceSets也可以完全自定义代码的目录结构便于代码的整理，例如：" class="headerlink" title="通过sourceSets也可以完全自定义代码的目录结构便于代码的整理，例如："></a>通过sourceSets也可以完全自定义代码的目录结构便于代码的整理，例如：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sourceSets&#123;</div><div class="line">	main &#123;</div><div class="line">		res.srcDirs = [&apos;src/main/res/&apos;,&apos;src/main/res/layout/activity&apos;,&apos;src/main/res/layout/fragment&apos;]</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h5 id="在这个脚本中，更改了默认的sourceSets，在原有src-main-res资源目录下增加了两个新目录activity跟fragment，在新建的两个目录中新建layout目录（因为Android资源文件只能识别该目录），重新编译可以发现，新增的两个目录activity跟fragment已经被识别为资源目录了，这样在代码中可以直接使用。对于项目路的管理整个结构一目了然。"><a href="#在这个脚本中，更改了默认的sourceSets，在原有src-main-res资源目录下增加了两个新目录activity跟fragment，在新建的两个目录中新建layout目录（因为Android资源文件只能识别该目录），重新编译可以发现，新增的两个目录activity跟fragment已经被识别为资源目录了，这样在代码中可以直接使用。对于项目路的管理整个结构一目了然。" class="headerlink" title="在这个脚本中，更改了默认的sourceSets，在原有src/main/res资源目录下增加了两个新目录activity跟fragment，在新建的两个目录中新建layout目录（因为Android资源文件只能识别该目录），重新编译可以发现，新增的两个目录activity跟fragment已经被识别为资源目录了，这样在代码中可以直接使用。对于项目路的管理整个结构一目了然。"></a>在这个脚本中，更改了默认的sourceSets，在原有src/main/res资源目录下增加了两个新目录activity跟fragment，在新建的两个目录中新建layout目录（因为Android资源文件只能识别该目录），重新编译可以发现，新增的两个目录activity跟fragment已经被识别为资源目录了，这样在代码中可以直接使用。对于项目路的管理整个结构一目了然。</h5><h2 id="三、构建全局配置"><a href="#三、构建全局配置" class="headerlink" title="三、构建全局配置"></a>三、构建全局配置</h2><h5 id="我们平时写代码，对于多处都要使用的常量，通常会提取出来作为一个全局常量。同样的，在Gradle中也可以使用全局配置，例如在多个moudle中配置compileSdkVersion等参数："><a href="#我们平时写代码，对于多处都要使用的常量，通常会提取出来作为一个全局常量。同样的，在Gradle中也可以使用全局配置，例如在多个moudle中配置compileSdkVersion等参数：" class="headerlink" title="我们平时写代码，对于多处都要使用的常量，通常会提取出来作为一个全局常量。同样的，在Gradle中也可以使用全局配置，例如在多个moudle中配置compileSdkVersion等参数："></a>我们平时写代码，对于多处都要使用的常量，通常会提取出来作为一个全局常量。同样的，在Gradle中也可以使用全局配置，例如在多个moudle中配置compileSdkVersion等参数：</h5><ol>
<li><p>配置全局参数(注意一定是ext)</p>
<h5 id="在根目录下的build-gradle中，通过ext领域可以制定全局的配置信息，代码如下"><a href="#在根目录下的build-gradle中，通过ext领域可以制定全局的配置信息，代码如下" class="headerlink" title="在根目录下的build.gradle中，通过ext领域可以制定全局的配置信息，代码如下:"></a>在根目录下的build.gradle中，通过ext领域可以制定全局的配置信息，代码如下:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ext &#123;</div><div class="line">	compileSdkVersion=23</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>引用配置</p>
<h5 id="在配置好全局参数后，就可以在每个moudle中使用这些配置了："><a href="#在配置好全局参数后，就可以在每个moudle中使用这些配置了：" class="headerlink" title="在配置好全局参数后，就可以在每个moudle中使用这些配置了："></a>在配置好全局参数后，就可以在每个moudle中使用这些配置了：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">	compileSdkVersion rootProject.ext.compileSdkVersion</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="方法非常简单，通过rootProject-ext可以引用所有的全局参数，另外我们也可以把ext全局配置写在allprojects领域中，这样在每个moudle中就可以直接引用申的变量了："><a href="#方法非常简单，通过rootProject-ext可以引用所有的全局参数，另外我们也可以把ext全局配置写在allprojects领域中，这样在每个moudle中就可以直接引用申的变量了：" class="headerlink" title="方法非常简单，通过rootProject.ext可以引用所有的全局参数，另外我们也可以把ext全局配置写在allprojects领域中，这样在每个moudle中就可以直接引用申的变量了："></a>方法非常简单，通过rootProject.ext可以引用所有的全局参数，另外我们也可以把ext全局配置写在allprojects领域中，这样在每个moudle中就可以直接引用申的变量了：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">	repositories&#123;</div><div class="line">		jcenter()</div><div class="line">		&#125;</div><div class="line">	ext &#123;</div><div class="line">		COMPILE_SDK_VERSION = 22</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="这样写的好处是可以讲配置统一管理，但是Grandle的版本更新通知检查机制就无效了。"><a href="#这样写的好处是可以讲配置统一管理，但是Grandle的版本更新通知检查机制就无效了。" class="headerlink" title="这样写的好处是可以讲配置统一管理，但是Grandle的版本更新通知检查机制就无效了。"></a>这样写的好处是可以讲配置统一管理，但是Grandle的版本更新通知检查机制就无效了。</h5><h2 id="四、构建defaultConfig"><a href="#四、构建defaultConfig" class="headerlink" title="四、构建defaultConfig"></a>四、构建defaultConfig</h2><h5 id="前面我们提到过Gradle脚本android领域中的defaultConfig领域，但没有做详细分析，现在我们将对defaultConfig做进一步解释，默认代码如下："><a href="#前面我们提到过Gradle脚本android领域中的defaultConfig领域，但没有做详细分析，现在我们将对defaultConfig做进一步解释，默认代码如下：" class="headerlink" title="前面我们提到过Gradle脚本android领域中的defaultConfig领域，但没有做详细分析，现在我们将对defaultConfig做进一步解释，默认代码如下："></a>前面我们提到过Gradle脚本android领域中的defaultConfig领域，但没有做详细分析，现在我们将对defaultConfig做进一步解释，默认代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">       applicationId &quot;com.night.cool.coolkline&quot;</div><div class="line">       minSdkVersion 15</div><div class="line">       targetSdkVersion 22</div><div class="line">       versionCode VERSION_SDK</div><div class="line">       versionName &quot;1.0&quot;</div><div class="line">       testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="我们可以在脚本里动态控制其中的参数，例如："><a href="#我们可以在脚本里动态控制其中的参数，例如：" class="headerlink" title="我们可以在脚本里动态控制其中的参数，例如："></a>我们可以在脚本里动态控制其中的参数，例如：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> defaultConfig &#123;</div><div class="line">        applicationId &quot;com.night.cool.coolkline&quot;</div><div class="line">        minSdkVersion 15</div><div class="line">        targetSdkVersion 22</div><div class="line">        versionCode VERSION_SDK</div><div class="line">        versionName getVersionName()</div><div class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</div><div class="line">    &#125;</div><div class="line">def getVersionName()&#123;</div><div class="line">	return &quot;3&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="五、构建buildTypes"><a href="#五、构建buildTypes" class="headerlink" title="五、构建buildTypes"></a>五、构建buildTypes</h2><h3 id="（一）构建基础"><a href="#（一）构建基础" class="headerlink" title="（一）构建基础"></a>（一）构建基础</h3><h5 id="通过创建不同的构建类型，从而生成不同类型的apk，例如实现只有在debug下才开启的log功能，以及为不同的构建类型实现不同的参数配置等。在android领域中系统默认配置了buildTypes"><a href="#通过创建不同的构建类型，从而生成不同类型的apk，例如实现只有在debug下才开启的log功能，以及为不同的构建类型实现不同的参数配置等。在android领域中系统默认配置了buildTypes" class="headerlink" title="通过创建不同的构建类型，从而生成不同类型的apk，例如实现只有在debug下才开启的log功能，以及为不同的构建类型实现不同的参数配置等。在android领域中系统默认配置了buildTypes:"></a>通过创建不同的构建类型，从而生成不同类型的apk，例如实现只有在debug下才开启的log功能，以及为不同的构建类型实现不同的参数配置等。在android领域中系统默认配置了buildTypes:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line">     release &#123;</div><div class="line">         minifyEnabled false</div><div class="line">         proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h5 id="如果直接在终端中执行gradle-build命令，那么系统会在module的output-apk目录下创建生成apk文件-那么除了系统默认的debug跟release版本我们也可以自定义创建新的构建类型，例如我们在脚本中新增一个cool类型，同时修改该类型的applicationIdSuffix-代码如下所示："><a href="#如果直接在终端中执行gradle-build命令，那么系统会在module的output-apk目录下创建生成apk文件-那么除了系统默认的debug跟release版本我们也可以自定义创建新的构建类型，例如我们在脚本中新增一个cool类型，同时修改该类型的applicationIdSuffix-代码如下所示：" class="headerlink" title="如果直接在终端中执行gradle build命令，那么系统会在module的output/apk目录下创建生成apk文件,那么除了系统默认的debug跟release版本我们也可以自定义创建新的构建类型，例如我们在脚本中新增一个cool类型，同时修改该类型的applicationIdSuffix,代码如下所示："></a>如果直接在终端中执行gradle build命令，那么系统会在module的output/apk目录下创建生成apk文件,那么除了系统默认的debug跟release版本我们也可以自定义创建新的构建类型，例如我们在脚本中新增一个cool类型，同时修改该类型的applicationIdSuffix,代码如下所示：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  buildTypes &#123;</div><div class="line">       release &#123;</div><div class="line">           minifyEnabled false</div><div class="line">           proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">       &#125;</div><div class="line">cool &#123;</div><div class="line">   applicationIdSuffix &quot;.cool&quot;</div><div class="line">&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="再次执行gradle-clean-amp-gradle-build指令，可以发现生成的apk多了cool系列的。那么applicationIdSuffix的作用是什么呢？我们知道Android中系统通过报名来区分应用的。如果包名相同则认为是一个应用，因此在构建类型的时候，可以指定applicationIdSuffix来为默认的包名增加一个后缀，以此来区分不同的构建类型。"><a href="#再次执行gradle-clean-amp-gradle-build指令，可以发现生成的apk多了cool系列的。那么applicationIdSuffix的作用是什么呢？我们知道Android中系统通过报名来区分应用的。如果包名相同则认为是一个应用，因此在构建类型的时候，可以指定applicationIdSuffix来为默认的包名增加一个后缀，以此来区分不同的构建类型。" class="headerlink" title="再次执行gradle clean &amp; gradle build指令，可以发现生成的apk多了cool系列的。那么applicationIdSuffix的作用是什么呢？我们知道Android中系统通过报名来区分应用的。如果包名相同则认为是一个应用，因此在构建类型的时候，可以指定applicationIdSuffix来为默认的包名增加一个后缀，以此来区分不同的构建类型。"></a>再次执行gradle clean &amp; gradle build指令，可以发现生成的apk多了cool系列的。那么applicationIdSuffix的作用是什么呢？我们知道Android中系统通过报名来区分应用的。如果包名相同则认为是一个应用，因此在构建类型的时候，可以指定applicationIdSuffix来为默认的包名增加一个后缀，以此来区分不同的构建类型。</h5><h3 id="二-构建类型buildTypes继承"><a href="#二-构建类型buildTypes继承" class="headerlink" title="(二)构建类型buildTypes继承"></a>(二)构建类型buildTypes继承</h3><h5 id="当创建自定义构建类型时，不仅仅可以完全创建一个新类型，而且还可以通过继承一个已有的构建类型来创建新的构建类型，代码如下："><a href="#当创建自定义构建类型时，不仅仅可以完全创建一个新类型，而且还可以通过继承一个已有的构建类型来创建新的构建类型，代码如下：" class="headerlink" title="当创建自定义构建类型时，不仅仅可以完全创建一个新类型，而且还可以通过继承一个已有的构建类型来创建新的构建类型，代码如下："></a>当创建自定义构建类型时，不仅仅可以完全创建一个新类型，而且还可以通过继承一个已有的构建类型来创建新的构建类型，代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  buildTypes &#123;</div><div class="line">       release &#123;</div><div class="line">           minifyEnabled false</div><div class="line">           proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">       &#125;</div><div class="line">cool.initWith(buildTypes.debug)</div><div class="line">cool &#123;</div><div class="line">   applicationIdSuffix &quot;.cool&quot;</div><div class="line">&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="通过以上代码，cool构建类型就继承了默认的debug构建类型的配置。"><a href="#通过以上代码，cool构建类型就继承了默认的debug构建类型的配置。" class="headerlink" title="通过以上代码，cool构建类型就继承了默认的debug构建类型的配置。"></a>通过以上代码，cool构建类型就继承了默认的debug构建类型的配置。</h5><h2 id="六、构建signingConfigs"><a href="#六、构建signingConfigs" class="headerlink" title="六、构建signingConfigs"></a>六、构建signingConfigs</h2><h5 id="Android-Apk通过签名来保证APP的合法性，系统会默认生成一个debug版本的签名，debug包会默认使用这个签名，那么当你需要给其他版本设置签名时，就需要自己来配置signingConfigs领域。"><a href="#Android-Apk通过签名来保证APP的合法性，系统会默认生成一个debug版本的签名，debug包会默认使用这个签名，那么当你需要给其他版本设置签名时，就需要自己来配置signingConfigs领域。" class="headerlink" title="Android Apk通过签名来保证APP的合法性，系统会默认生成一个debug版本的签名，debug包会默认使用这个签名，那么当你需要给其他版本设置签名时，就需要自己来配置signingConfigs领域。"></a>Android Apk通过签名来保证APP的合法性，系统会默认生成一个debug版本的签名，debug包会默认使用这个签名，那么当你需要给其他版本设置签名时，就需要自己来配置signingConfigs领域。</h5><h3 id="（一）生成签名"><a href="#（一）生成签名" class="headerlink" title="（一）生成签名"></a>（一）生成签名</h3><h5 id="通过Generate-Signed-APK来生成。但需要注意的是，通常会把签名文件保存路径选择到主moudle的根目录下。"><a href="#通过Generate-Signed-APK来生成。但需要注意的是，通常会把签名文件保存路径选择到主moudle的根目录下。" class="headerlink" title="通过Generate Signed APK来生成。但需要注意的是，通常会把签名文件保存路径选择到主moudle的根目录下。"></a>通过Generate Signed APK来生成。但需要注意的是，通常会把签名文件保存路径选择到主moudle的根目录下。</h5><h3 id="二-配置签名"><a href="#二-配置签名" class="headerlink" title="(二)配置签名"></a>(二)配置签名</h3><h5 id="生成了签名文件后，就可以在build-gradle脚本的android领域中配置签名相关的参数了。"><a href="#生成了签名文件后，就可以在build-gradle脚本的android领域中配置签名相关的参数了。" class="headerlink" title="生成了签名文件后，就可以在build.gradle脚本的android领域中配置签名相关的参数了。"></a>生成了签名文件后，就可以在build.gradle脚本的android领域中配置签名相关的参数了。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">signingConfigs &#123;</div><div class="line">	cool &#123;</div><div class="line">		storeFile file(&quot;cool_key.jks&quot;)</div><div class="line">		storePassword &quot;123456&quot;</div><div class="line">		keyAlias &quot;cool&quot;</div><div class="line">		keyPassword &quot;1234567&quot;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="配置的信息就是前面创建签名时，填写的信息。需要注意的是，签名信息一定要包含在一个领域中，你可以为这个领域起一个名字，例如这里的cool。"><a href="#配置的信息就是前面创建签名时，填写的信息。需要注意的是，签名信息一定要包含在一个领域中，你可以为这个领域起一个名字，例如这里的cool。" class="headerlink" title="配置的信息就是前面创建签名时，填写的信息。需要注意的是，签名信息一定要包含在一个领域中，你可以为这个领域起一个名字，例如这里的cool。"></a>配置的信息就是前面创建签名时，填写的信息。需要注意的是，签名信息一定要包含在一个领域中，你可以为这个领域起一个名字，例如这里的cool。</h5><h3 id="三-使用签名"><a href="#三-使用签名" class="headerlink" title="(三)使用签名"></a>(三)使用签名</h3><h5 id="配置好相关的签名信息后，就可以在构建类型是加入签名的设置。这样生成的apk就会包含签名版。代码如下："><a href="#配置好相关的签名信息后，就可以在构建类型是加入签名的设置。这样生成的apk就会包含签名版。代码如下：" class="headerlink" title="配置好相关的签名信息后，就可以在构建类型是加入签名的设置。这样生成的apk就会包含签名版。代码如下："></a>配置好相关的签名信息后，就可以在构建类型是加入签名的设置。这样生成的apk就会包含签名版。代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">signingConfigs &#123;</div><div class="line">	cool &#123;</div><div class="line">		storeFile file(&quot;cool_key.jks&quot;)</div><div class="line">		storePassword &quot;123456&quot;</div><div class="line">		keyAlias &quot;cool&quot;</div><div class="line">		keyPassword &quot;1234567&quot;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">buildTypes &#123;</div><div class="line">	release &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">	cool &#123;</div><div class="line">		signingConfig signingConfigs.cool</div><div class="line">		applicationIdSuffix &quot;.cool&quot;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="七、Android领域中的可选配置"><a href="#七、Android领域中的可选配置" class="headerlink" title="七、Android领域中的可选配置"></a>七、Android领域中的可选配置</h2><h5 id="在Android领域中，还有一些可选的配置。在具体的开发场景中，开发者可以根据自己的需要进行配置。"><a href="#在Android领域中，还有一些可选的配置。在具体的开发场景中，开发者可以根据自己的需要进行配置。" class="headerlink" title="在Android领域中，还有一些可选的配置。在具体的开发场景中，开发者可以根据自己的需要进行配置。"></a>在Android领域中，还有一些可选的配置。在具体的开发场景中，开发者可以根据自己的需要进行配置。</h5><h3 id="一-compileOptions"><a href="#一-compileOptions" class="headerlink" title="(一)compileOptions"></a>(一)compileOptions</h3><h5 id="顾名思义，这是设置Java的编译选项，通常可以在这里制定Java的编译版本，示例代码如下："><a href="#顾名思义，这是设置Java的编译选项，通常可以在这里制定Java的编译版本，示例代码如下：" class="headerlink" title="顾名思义，这是设置Java的编译选项，通常可以在这里制定Java的编译版本，示例代码如下："></a>顾名思义，这是设置Java的编译选项，通常可以在这里制定Java的编译版本，示例代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">compileOptions &#123;</div><div class="line">	sourceCompatibility JavaVersion.VERSION_1_8</div><div class="line">	targetCompatibility JavaVersion.VERSION_1_8</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="制定编译版本，通常是为了使用某些版本中的一些语言新特性。"><a href="#制定编译版本，通常是为了使用某些版本中的一些语言新特性。" class="headerlink" title="制定编译版本，通常是为了使用某些版本中的一些语言新特性。"></a>制定编译版本，通常是为了使用某些版本中的一些语言新特性。</h5><h3 id="（二）lintOptions"><a href="#（二）lintOptions" class="headerlink" title="（二）lintOptions"></a>（二）lintOptions</h3><h5 id="这是用于控制lint代码检查。因为在Lint-Check时，编译会因为Lint的error二终止，通过这个选项，可以在lint-check发生error时候，继续编译："><a href="#这是用于控制lint代码检查。因为在Lint-Check时，编译会因为Lint的error二终止，通过这个选项，可以在lint-check发生error时候，继续编译：" class="headerlink" title="这是用于控制lint代码检查。因为在Lint Check时，编译会因为Lint的error二终止，通过这个选项，可以在lint check发生error时候，继续编译："></a>这是用于控制lint代码检查。因为在Lint Check时，编译会因为Lint的error二终止，通过这个选项，可以在lint check发生error时候，继续编译：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lintOptions &#123;</div><div class="line">	abortOnError false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><h5 id="由于篇幅问题，这一节就讲到这里，下一节会继续讲解gradle进阶。"><a href="#由于篇幅问题，这一节就讲到这里，下一节会继续讲解gradle进阶。" class="headerlink" title="由于篇幅问题，这一节就讲到这里，下一节会继续讲解gradle进阶。"></a>由于篇幅问题，这一节就讲到这里，下一节会继续讲解gradle进阶。</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.coolcoolcoder.com/c_night/2017/10/18/Gradle之初探-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoolYellow">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coolyellow的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Gradle之初探-1/" itemprop="url">Gradle之初探.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T21:41:34+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h2><h5 id="我们通过studio创建一个工程，在整个项目里面默认会有四个Gradle构建文件，此外在moudle-app下还有一个build-gradle文件。Gradle在根目录中会有一个项目全局的build-gradle文件，而在每个模块下，同样会有针对该模块的build-gradle文件，后面我们会一一讲解，这一节我们现在讲讲项目全局的Gradle-Build文件－－build-gradle"><a href="#我们通过studio创建一个工程，在整个项目里面默认会有四个Gradle构建文件，此外在moudle-app下还有一个build-gradle文件。Gradle在根目录中会有一个项目全局的build-gradle文件，而在每个模块下，同样会有针对该模块的build-gradle文件，后面我们会一一讲解，这一节我们现在讲讲项目全局的Gradle-Build文件－－build-gradle" class="headerlink" title="我们通过studio创建一个工程，在整个项目里面默认会有四个Gradle构建文件，此外在moudle app下还有一个build.gradle文件。Gradle在根目录中会有一个项目全局的build.gradle文件，而在每个模块下，同样会有针对该模块的build.gradle文件，后面我们会一一讲解，这一节我们现在讲讲项目全局的Gradle Build文件－－build.gradle."></a>我们通过studio创建一个工程，在整个项目里面默认会有四个Gradle构建文件，此外在moudle app下还有一个build.gradle文件。Gradle在根目录中会有一个项目全局的build.gradle文件，而在每个模块下，同样会有针对该模块的build.gradle文件，后面我们会一一讲解，这一节我们现在讲讲项目全局的Gradle Build文件－－build.gradle.</h5><h2 id="二、项目全局build-gradle"><a href="#二、项目全局build-gradle" class="headerlink" title="二、项目全局build.gradle"></a>二、项目全局build.gradle</h2><h5 id="（一）一个完整的项目全局build-gradle文件如下所示："><a href="#（一）一个完整的项目全局build-gradle文件如下所示：" class="headerlink" title="（一）一个完整的项目全局build.gradle文件如下所示："></a>（一）一个完整的项目全局build.gradle文件如下所示：</h5><figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.android.tools.build:gradle:2.3.3&apos;</div><div class="line"></div><div class="line">        // NOTE: Do not place your application dependencies here; they belong</div><div class="line">        // in the individual module build.gradle files</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">task clean(type: Delete) &#123;</div><div class="line">    delete rootProject.buildDir</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="（二）实际上项目全局的build-gradle文件中最重要的就是buildscript部分代码，其指定了使用jcenter代码仓库，同时声明了依赖的Android-Gradle插件的版本。而在allprojects领域中，我们可以为项目整体配置一些属性。"><a href="#（二）实际上项目全局的build-gradle文件中最重要的就是buildscript部分代码，其指定了使用jcenter代码仓库，同时声明了依赖的Android-Gradle插件的版本。而在allprojects领域中，我们可以为项目整体配置一些属性。" class="headerlink" title="（二）实际上项目全局的build.gradle文件中最重要的就是buildscript部分代码，其指定了使用jcenter代码仓库，同时声明了依赖的Android Gradle插件的版本。而在allprojects领域中，我们可以为项目整体配置一些属性。"></a>（二）实际上项目全局的build.gradle文件中最重要的就是buildscript部分代码，其指定了使用jcenter代码仓库，同时声明了依赖的Android Gradle插件的版本。而在allprojects领域中，我们可以为项目整体配置一些属性。</h5><h2 id="三、Moudle-build-gradle"><a href="#三、Moudle-build-gradle" class="headerlink" title="三、Moudle build.gradle"></a>三、Moudle build.gradle</h2><h5 id="Android-studio自动创建的moudle默认生成了build-gradle文件，内容如下"><a href="#Android-studio自动创建的moudle默认生成了build-gradle文件，内容如下" class="headerlink" title="Android studio自动创建的moudle默认生成了build.gradle文件，内容如下"></a>Android studio自动创建的moudle默认生成了build.gradle文件，内容如下</h5><figure class="highlight plain"><figcaption><span>plugin: 'com.android.application'</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">android &#123;</div><div class="line">    compileSdkVersion 26</div><div class="line">    buildToolsVersion &quot;26.0.0&quot;</div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId &quot;com.night.cool.coolkline&quot;</div><div class="line">        minSdkVersion 15</div><div class="line">        targetSdkVersion 26</div><div class="line">        versionCode 1</div><div class="line">        versionName &quot;1.0&quot;</div><div class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</div><div class="line">    &#125;</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            minifyEnabled false</div><div class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</div><div class="line">    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123;</div><div class="line">        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;</div><div class="line">    &#125;)</div><div class="line">    compile &apos;com.android.support:appcompat-v7:26.+&apos;</div><div class="line">    compile &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;</div><div class="line">    testCompile &apos;junit:junit:4.12&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="因为gradle是领域特定语言，所以我们只需要针对每个特定领域进行即可："><a href="#因为gradle是领域特定语言，所以我们只需要针对每个特定领域进行即可：" class="headerlink" title="因为gradle是领域特定语言，所以我们只需要针对每个特定领域进行即可："></a>因为gradle是领域特定语言，所以我们只需要针对每个特定领域进行即可：</h5><ol>
<li>apply plugin领域<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="表示module是一个Android-Application。这个插件包含了Android项目相关的所有工具。"><a href="#表示module是一个Android-Application。这个插件包含了Android项目相关的所有工具。" class="headerlink" title="表示module是一个Android Application。这个插件包含了Android项目相关的所有工具。"></a>表示module是一个Android Application。这个插件包含了Android项目相关的所有工具。</h5><ol>
<li>andorid 领域：<h5 id="android-……-这块领域包含了该Android-module构建过程中所用到的所有参数。默认情况下，IDE自动创建了compileSdkVersion、buildToolsVersion两个参数，分别对应编译的SDK版本和build-tools版本。另外其中的defaultConfig与buildTypes两个领域比较复杂我们后面在讲。"><a href="#android-……-这块领域包含了该Android-module构建过程中所用到的所有参数。默认情况下，IDE自动创建了compileSdkVersion、buildToolsVersion两个参数，分别对应编译的SDK版本和build-tools版本。另外其中的defaultConfig与buildTypes两个领域比较复杂我们后面在讲。" class="headerlink" title="android{……}这块领域包含了该Android module构建过程中所用到的所有参数。默认情况下，IDE自动创建了compileSdkVersion、buildToolsVersion两个参数，分别对应编译的SDK版本和build tools版本。另外其中的defaultConfig与buildTypes两个领域比较复杂我们后面在讲。"></a>android{……}这块领域包含了该Android module构建过程中所用到的所有参数。默认情况下，IDE自动创建了compileSdkVersion、buildToolsVersion两个参数，分别对应编译的SDK版本和build tools版本。另外其中的defaultConfig与buildTypes两个领域比较复杂我们后面在讲。</h5></li>
<li>dependencies　领域：<h5 id="dependencies-……-这块领域描述了Android-module构建过程中所依赖的所有库，可以是jar形式依赖，或者使用安卓推荐的aar形式依赖。aar相对于jar具有更大优势，不仅配置依赖简单，而且可以讲图片资源放入aar中供主项目使用，几乎等同于源码。"><a href="#dependencies-……-这块领域描述了Android-module构建过程中所依赖的所有库，可以是jar形式依赖，或者使用安卓推荐的aar形式依赖。aar相对于jar具有更大优势，不仅配置依赖简单，而且可以讲图片资源放入aar中供主项目使用，几乎等同于源码。" class="headerlink" title="dependencies{……}这块领域描述了Android module构建过程中所依赖的所有库，可以是jar形式依赖，或者使用安卓推荐的aar形式依赖。aar相对于jar具有更大优势，不仅配置依赖简单，而且可以讲图片资源放入aar中供主项目使用，几乎等同于源码。"></a>dependencies{……}这块领域描述了Android module构建过程中所依赖的所有库，可以是jar形式依赖，或者使用安卓推荐的aar形式依赖。aar相对于jar具有更大优势，不仅配置依赖简单，而且可以讲图片资源放入aar中供主项目使用，几乎等同于源码。</h5></li>
</ol>
<h2 id="四、local-properties"><a href="#四、local-properties" class="headerlink" title="四、local.properties"></a>四、local.properties</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdk.dir=/usr/lib/SDK/SDK</div></pre></td></tr></table></figure>
<h5 id="这里配置了Android-Gradle插件所需要使用的Android-SDK的路径，由于已经设置了Android-Home环境变量，所以IDE能够自动生成这个配置文件，一般不需要修改这个文件，除非要重新定义SDK的路径。"><a href="#这里配置了Android-Gradle插件所需要使用的Android-SDK的路径，由于已经设置了Android-Home环境变量，所以IDE能够自动生成这个配置文件，一般不需要修改这个文件，除非要重新定义SDK的路径。" class="headerlink" title="这里配置了Android Gradle插件所需要使用的Android SDK的路径，由于已经设置了Android_Home环境变量，所以IDE能够自动生成这个配置文件，一般不需要修改这个文件，除非要重新定义SDK的路径。"></a>这里配置了Android Gradle插件所需要使用的Android SDK的路径，由于已经设置了Android_Home环境变量，所以IDE能够自动生成这个配置文件，一般不需要修改这个文件，除非要重新定义SDK的路径。</h5><h2 id="五、Gradle-Task"><a href="#五、Gradle-Task" class="headerlink" title="五、Gradle Task"></a>五、Gradle Task</h2><h5 id="Task其实是Gradle最重要的组成部分，但是对于android开发来说我们只了解常用的即可。"><a href="#Task其实是Gradle最重要的组成部分，但是对于android开发来说我们只了解常用的即可。" class="headerlink" title="Task其实是Gradle最重要的组成部分，但是对于android开发来说我们只了解常用的即可。"></a>Task其实是Gradle最重要的组成部分，但是对于android开发来说我们只了解常用的即可。</h5><ol>
<li><p>assemble task:</p>
<h5 id="assemble-task用于组合项目的所有输出，它包含了assembleDebug跟assembleRelease两个task，通过执行gradle-assemble指令，Gradle会编译出两个Apk－－debug和release-如果要单独的编译命令，可以使用如下指令："><a href="#assemble-task用于组合项目的所有输出，它包含了assembleDebug跟assembleRelease两个task，通过执行gradle-assemble指令，Gradle会编译出两个Apk－－debug和release-如果要单独的编译命令，可以使用如下指令：" class="headerlink" title="assemble task用于组合项目的所有输出，它包含了assembleDebug跟assembleRelease两个task，通过执行gradle assemble指令，Gradle会编译出两个Apk－－debug和release,如果要单独的编译命令，可以使用如下指令："></a>assemble task用于组合项目的所有输出，它包含了assembleDebug跟assembleRelease两个task，通过执行gradle assemble指令，Gradle会编译出两个Apk－－debug和release,如果要单独的编译命令，可以使用如下指令：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gradle assembleRelease//简写gradle aR</div></pre></td></tr></table></figure>
</li>
<li><p>check:</p>
<h5 id="check-task用于执行检查任务"><a href="#check-task用于执行检查任务" class="headerlink" title="check task用于执行检查任务"></a>check task用于执行检查任务</h5></li>
<li>Build:<h5 id="build-task类似一个组合指令，它执行了check和assemble的所有工作"><a href="#build-task类似一个组合指令，它执行了check和assemble的所有工作" class="headerlink" title="build task类似一个组合指令，它执行了check和assemble的所有工作"></a>build task类似一个组合指令，它执行了check和assemble的所有工作</h5></li>
<li>Clean:<h5 id="clean-task用于清理所有的中间编译结果，当遇到一些比较莫名其妙的Gradle编译问题时，通常会先执行clean-task来清理中间数据，这类似于ID的clean工作。"><a href="#clean-task用于清理所有的中间编译结果，当遇到一些比较莫名其妙的Gradle编译问题时，通常会先执行clean-task来清理中间数据，这类似于ID的clean工作。" class="headerlink" title="clean task用于清理所有的中间编译结果，当遇到一些比较莫名其妙的Gradle编译问题时，通常会先执行clean task来清理中间数据，这类似于ID的clean工作。"></a>clean task用于清理所有的中间编译结果，当遇到一些比较莫名其妙的Gradle编译问题时，通常会先执行clean task来清理中间数据，这类似于ID的clean工作。</h5><h4 id="想要执行某个task，直接使用gradle-task-name即可，例如gradle-clean。"><a href="#想要执行某个task，直接使用gradle-task-name即可，例如gradle-clean。" class="headerlink" title="想要执行某个task，直接使用gradle task_name即可，例如gradle clean。"></a>想要执行某个task，直接使用gradle task_name即可，例如gradle clean。</h4></li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><h5 id="这一节我们只是大概的了解了一下gradle，下一节我们对gradle进行进一步的讲解，这里十分建议大家多去官网查看资料，好了今天就到这里了，下节再见。"><a href="#这一节我们只是大概的了解了一下gradle，下一节我们对gradle进行进一步的讲解，这里十分建议大家多去官网查看资料，好了今天就到这里了，下节再见。" class="headerlink" title="这一节我们只是大概的了解了一下gradle，下一节我们对gradle进行进一步的讲解，这里十分建议大家多去官网查看资料，好了今天就到这里了，下节再见。"></a>这一节我们只是大概的了解了一下gradle，下一节我们对gradle进行进一步的讲解，这里十分建议大家多去官网查看资料，好了今天就到这里了，下节再见。</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">CoolYellow</p>
              <p class="site-description motion-element" itemprop="description">c_night</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoolYellow</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
